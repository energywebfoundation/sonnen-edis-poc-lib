{ "abi": [{ "constant": true, "inputs": [{ "name": "_interfaceID", "type": "bytes4" }], "name": "supportsInterface", "outputs": [{ "name": "", "type": "bool" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [{ "name": "_tokenId", "type": "uint256" }], "name": "getApproved", "outputs": [{ "name": "", "type": "address" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "name": "_approved", "type": "address" }, { "name": "_entityId", "type": "uint256" }], "name": "approve", "outputs": [], "payable": true, "stateMutability": "payable", "type": "function" }, { "constant": false, "inputs": [{ "name": "_certificateId", "type": "uint256" }, { "name": "_escrow", "type": "address" }], "name": "addEscrowForEntity", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "name": "_newLogic", "type": "address" }], "name": "update", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "name": "_from", "type": "address" }, { "name": "_to", "type": "address" }, { "name": "_entityId", "type": "uint256" }], "name": "transferFrom", "outputs": [], "payable": true, "stateMutability": "payable", "type": "function" }, { "constant": false, "inputs": [{ "name": "_assetId", "type": "uint256" }, { "name": "_powerInW", "type": "uint256" }], "name": "createTradableEntity", "outputs": [{ "name": "", "type": "uint256" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "name": "_from", "type": "address" }, { "name": "_to", "type": "address" }, { "name": "_entityId", "type": "uint256" }], "name": "safeTransferFrom", "outputs": [], "payable": true, "stateMutability": "payable", "type": "function" }, { "constant": true, "inputs": [], "name": "userContractLookup", "outputs": [{ "name": "", "type": "address" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "db", "outputs": [{ "name": "", "type": "address" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "name": "_entityId", "type": "uint256" }, { "name": "_price", "type": "uint256" }], "name": "setOnChainDirectPurchasePrice", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [{ "name": "_entityId", "type": "uint256" }], "name": "ownerOf", "outputs": [{ "name": "", "type": "address" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "assetContractLookup", "outputs": [{ "name": "", "type": "address" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [{ "name": "_matcher", "type": "address[]" }], "name": "checkMatcher", "outputs": [{ "name": "", "type": "bool" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [{ "name": "_owner", "type": "address" }], "name": "balanceOf", "outputs": [{ "name": "", "type": "uint256" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [{ "name": "_entityId", "type": "uint256" }], "name": "getTradableEntity", "outputs": [{ "components": [{ "name": "assetId", "type": "uint256" }, { "name": "owner", "type": "address" }, { "name": "powerInW", "type": "uint256" }, { "name": "acceptedToken", "type": "address" }, { "name": "onChainDirectPurchasePrice", "type": "uint256" }, { "name": "escrow", "type": "address[]" }, { "name": "approvedAddress", "type": "address" }], "name": "", "type": "tuple" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "owner", "outputs": [{ "name": "", "type": "address" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "name": "_escrow", "type": "address" }, { "name": "_approved", "type": "bool" }], "name": "setApprovalForAll", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "name": "_newOwner", "type": "address" }], "name": "changeOwner", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "name": "_from", "type": "address" }, { "name": "_to", "type": "address" }, { "name": "_entityId", "type": "uint256" }, { "name": "_data", "type": "bytes" }], "name": "safeTransferFrom", "outputs": [], "payable": true, "stateMutability": "payable", "type": "function" }, { "constant": true, "inputs": [{ "name": "_role", "type": "uint8" }, { "name": "_caller", "type": "address" }], "name": "isRole", "outputs": [{ "name": "", "type": "bool" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "name": "_certificateId", "type": "uint256" }, { "name": "_escrow", "type": "address" }], "name": "removeEscrow", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "name": "_entityId", "type": "uint256" }, { "name": "_tokenContract", "type": "address" }], "name": "setTradableToken", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [{ "name": "_entityId", "type": "uint256" }], "name": "getOnChainDirectPurchasePrice", "outputs": [{ "name": "", "type": "uint256" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [{ "name": "_owner", "type": "address" }, { "name": "_operator", "type": "address" }], "name": "isApprovedForAll", "outputs": [{ "name": "", "type": "bool" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "name": "_database", "type": "address" }, { "name": "_admin", "type": "address" }], "name": "init", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [{ "name": "_entityId", "type": "uint256" }], "name": "getTradableToken", "outputs": [{ "name": "", "type": "address" }], "payable": false, "stateMutability": "view", "type": "function" }, { "inputs": [{ "name": "_assetContractLookup", "type": "address" }, { "name": "_originContractLookup", "type": "address" }], "payable": false, "stateMutability": "nonpayable", "type": "constructor" }, { "anonymous": false, "inputs": [{ "indexed": true, "name": "_from", "type": "address" }, { "indexed": true, "name": "_to", "type": "address" }, { "indexed": true, "name": "_tokenId", "type": "uint256" }], "name": "Transfer", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "name": "_owner", "type": "address" }, { "indexed": true, "name": "_approved", "type": "address" }, { "indexed": true, "name": "_tokenId", "type": "uint256" }], "name": "Approval", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "name": "_owner", "type": "address" }, { "indexed": true, "name": "_operator", "type": "address" }, { "indexed": false, "name": "_approved", "type": "bool" }], "name": "ApprovalForAll", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "name": "_certificateId", "type": "uint256" }, { "indexed": false, "name": "_escrow", "type": "address" }], "name": "LogEscrowRemoved", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "name": "_certificateId", "type": "uint256" }, { "indexed": false, "name": "_escrow", "type": "address" }], "name": "LogEscrowAdded", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": false, "name": "_newOwner", "type": "address" }], "name": "LogChangeOwner", "type": "event" }], "bytecode": "", "contractName": "TradableEntityLogic", "deployedBytecode": "", "source": "// Copyright 2018 Energy Web Foundation\n// This file is part of the Origin Application brought to you by the Energy Web Foundation,\n// a global non-profit organization focused on accelerating blockchain technology across the energy sector,\n// incorporated in Zug, Switzerland.\n//\n// The Origin Application is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n// This is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY and without an implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details, at <http://www.gnu.org/licenses/>.\n//\n// @authors: slock.it GmbH; Martin Kuechler, martin.kuchler@slock.it; Heiko Burkhardt, heiko.burkhardt@slock.it;\n\npragma solidity ^0.5.0;\npragma experimental ABIEncoderV2;\n\nimport \"ew-user-registry-contracts/contracts/Users/RoleManagement.sol\";\nimport \"ew-utils-general-contracts/contracts/Interfaces/Updatable.sol\";\nimport \"../../contracts/Origin/TradableEntityContract.sol\";\nimport \"../../contracts/Interfaces/ERC721.sol\";\nimport \"../../contracts/Interfaces/ERC721TokenReceiver.sol\";\nimport \"../../contracts/Interfaces/ERC165.sol\";\nimport \"ew-asset-registry-contracts/contracts/Interfaces/AssetProducingInterface.sol\";\nimport \"../../contracts/Origin/EnergyDB.sol\";\nimport \"../../contracts/Interfaces/TradableEntityDBInterface.sol\";\nimport \"../../contracts/Interfaces/OriginContractLookupInterface.sol\";\nimport \"../../contracts/Interfaces/TradableEntityInterface.sol\";\nimport \"ew-asset-registry-contracts/contracts/Interfaces/AssetContractLookupInterface.sol\";\nimport \"ew-user-registry-contracts/contracts/Interfaces/UserContractLookupInterface.sol\";\n\n/// @title Contract for storing the current logic-contracts-addresses for the certificate of origin\ncontract TradableEntityLogic is Updatable, RoleManagement, ERC721, ERC165, TradableEntityInterface {\n\n    TradableEntityDBInterface public db;\n    AssetContractLookupInterface public assetContractLookup;\n\n    /// @notice Logs when a transfer or creation of a tradableEntity occurs\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n    /// @notice Logs when an address gets approved\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n    /// @notice Logs when an ApprovedForAll gets triggered\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    /// @notice Logs when an escrow gets removed\n    event LogEscrowRemoved(uint indexed _certificateId, address _escrow);\n    /// @notice Logs when an escrow gets added\n    event LogEscrowAdded(uint indexed _certificateId, address _escrow);\n\n    modifier onlyEntityOwner(uint _entityId) {\n        require(db.getTradableEntityOwner(_entityId) == msg.sender,\"not the enitity-owner\");\n        _;\n    }\n\n    /// @notice Constructor\n    /// @param _assetContractLookup assetContractLookupRegistry-contract address\n    /// @param _originContractLookup originContractLookup contract address\n    constructor(\n        AssetContractLookupInterface _assetContractLookup,\n        OriginContractLookupInterface _originContractLookup\n    )\n        RoleManagement((UserContractLookupInterface((_assetContractLookup.userRegistry()))), address(_originContractLookup))\n        public\n    {\n        assetContractLookup = _assetContractLookup;\n    }\n\n    /**\n        abstract function\n    */\n    /// @notice creates a tradable entity\n    /// @param _assetId the id of the asset that produced the energy\n    /// @param _powerInW the amount of energy produced\n    /// @return the id of the newly created entity\n    function createTradableEntity(uint _assetId, uint _powerInW) external returns (uint);\n    \n    /**\n        ERC721 functions\n     */\n\n    /// @notice gets the balance of an owner\n    /// @param _owner the owner\n    /// @return the amount of entitys of the owner\n    function balanceOf(address _owner) external view returns (uint256){\n        require(_owner != address(0x0),\"address 0x0 not allowed\");\n        return db.getBalanceOf(_owner);\n    }\n\n    /// @notice returns the owner of an entity\n    /// @param _entityId the entity id\n    /// @return address of the owner\n    function ownerOf(uint256 _entityId) external view returns (address){\n        address owner = db.getTradableEntityOwner(_entityId);\n        require(owner != address(0x0),\"address 0x0 not allowed\");\n        return owner;\n    }\n\n    /// @notice safeTransferFrom function (see ERC721 definition)\n    /// @param _from sender/owner of the entity\n    /// @param _to receiver / new owner of the entity\n    /// @param _entityId the entity-id\n    /// @param _data calldata to be passed\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _entityId,\n        bytes calldata _data\n    )\n        external\n        payable\n    {\n        simpleTransferInternal(_from, _to, _entityId);\n        safeTransferChecks(_from, _to, _entityId, _data);\n    }\n\n    /// @notice safeTransferFrom function (see ERC721 definition)\n    /// @param _from sender/owner of the entity\n    /// @param _to receiver / new owner of the entity\n    /// @param _entityId the entity-id\n    function safeTransferFrom(address _from, address _to, uint256 _entityId) external payable {\n        bytes memory data = \"\";\n        simpleTransferInternal(_from, _to, _entityId);\n        safeTransferChecks(_from, _to, _entityId, data);\n    }\n\n    /// @notice simple transfer function\n    /// @param _from sender/owner of the entity\n    /// @param _to receiver / new owner of the entity\n    /// @param _entityId the entity-id\n    function transferFrom(address _from, address _to, uint256 _entityId) external payable {\n        simpleTransferInternal(_from, _to, _entityId);\n    }\n\n    /// @notice approves an address for an entity\n    /// @param _approved address to be approved\n    /// @param _entityId the entity-id\n    function approve(address _approved, uint256 _entityId) external payable {\n        TradableEntityContract.TradableEntity memory te = TradableEntityDB(address(db)).getTradableEntity(_entityId);\n        require(te.owner == msg.sender || checkMatcher(te.escrow),\"approve: not owner / matcher\");\n        db.addApprovalExternal(_entityId, _approved);\n\n        emit Approval(msg.sender,_approved, _entityId);\n    }\n\n    /// @notice Removes an escrow-address of a certifiacte\n    /// @param _certificateId The id of the certificate\n    /// @param _escrow The address to be removed\n    function removeEscrow(uint _certificateId, address _escrow) external onlyEntityOwner(_certificateId){\n        require(db.removeEscrow(_certificateId, _escrow),\"escrow address not in array\");\n        emit LogEscrowRemoved(_certificateId, _escrow);\n    }\n\n    /// @notice sets approve\n    /// @param _escrow the address to be approved for all entities of an owner\n    /// @param _approved the approved flag\n    function setApprovalForAll(address _escrow, bool _approved) external {\n        db.setOwnerToOperators(msg.sender, _escrow, _approved);\n        emit ApprovalForAll(msg.sender, _escrow, _approved);\n    }\n\n    /// @notice gets the approved account of an entity\n    /// @param _tokenId the entity id\n    function getApproved(uint _tokenId) external view returns (address) {\n        return db.getApproved(_tokenId);\n    }\n\n    /// @notice returns whether the operator (escrow) is approved for the company\n    /// @param _owner the owner / company\n    /// @param _operator the operator / escrow\n    /// @return flag whether the operator is approved\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\n        return db.getOwnerToOperators(_owner, _operator);\n    }\n\n     /**\n        external non erc721 functions\n    */\n\n    /// @notice adds a new escrow address to a certificate\n    /// @param _certificateId The id of the certificate\n    /// @param _escrow The additional escrow address\n    function addEscrowForEntity(uint _certificateId, address _escrow)\n        external\n        onlyEntityOwner(_certificateId)\n    {\n        require(db.getTradableEntityEscrowLength(_certificateId) < OriginContractLookupInterface(owner).maxMatcherPerCertificate(),\"maximum amount of escrows reached\");\n        db.addEscrowForEntity(_certificateId, _escrow);\n        emit LogEscrowAdded(_certificateId, _escrow);\n    }\n\n    /// @notice initializes the contract by binding it to a logic contract\n    /// @param _database Sets the logic contract\n    function init(address _database, address _admin) external onlyOwner {\n        require(db == TradableEntityDBInterface(0x0));\n        db = TradableEntityDBInterface(_database);\n    }\n\n    /// @notice sets the direct purchase price for onchain\n    /// @param _entityId the id of the entity\n    /// @param _price the on chain direct purchase price\n    function setOnChainDirectPurchasePrice(\n        uint _entityId,\n        uint _price\n    )\n        onlyEntityOwner(_entityId)\n        external\n    {\n        db.setOnChainDirectPurchasePrice(_entityId, _price);\n    }\n\n    /// @notice sets the tradable token (ERC20 contract)\n    /// @param _entityId the id of the entity\n    /// @param _tokenContract the ERC20 tokenContract\n    function setTradableToken(\n        uint _entityId,\n        address _tokenContract\n    )\n        onlyEntityOwner(_entityId)\n        external\n    {\n        db.setTradableToken(_entityId, _tokenContract);\n    }\n\n\n    /// @notice Updates the logic contract\n    /// @param _newLogic Address of the new logic contract\n    function update(address _newLogic)\n        external\n        onlyOwner\n    {\n        Owned(address(db)).changeOwner(_newLogic);\n    }\n\n\n    /// @notice gets the onchain direct purchase price\n    /// @param _entityId the id of the entity\n    /// @return the number of ERC20 required to buy the entity\n    function getOnChainDirectPurchasePrice(uint _entityId) external view returns (uint) {\n        return db.getOnChainDirectPurchasePrice(_entityId);\n    }\n\n\n    /// @notice gets the tradableEntity\n    /// @param _entityId the id of the entity\n    /// @return the tradableEntity\n    function getTradableEntity(uint _entityId)\n        external\n        view\n        returns (\n            TradableEntityContract.TradableEntity memory\n        )\n    {\n        return TradableEntityDB(address(db)).getTradableEntity(_entityId);\n    }\n\n    /// @notice gets the tradable token\n    /// @param _entityId the id of an entity\n    /// @return the tradable token (ERC20 contract)\n    function getTradableToken(uint _entityId) external view returns (address){\n        return db.getTradableToken(_entityId);\n    }\n\n    /// @notice functions that checks whether this contract supports a certain interfaceId\n    /// @param _interfaceID the interfaceId\n    /// @return true if interfaceId == 0x80ac58cd\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool){\n        if(_interfaceID == 0x80ac58cd) return true;\n    }\n\n    /**\n        public functions\n     */\n    /// @notice Checks if the msg.sender is included in the matcher-array\n    /// @param _matcher the array with matchers\n    /// @return true when the msg.sender is in the matcher-array\n    function checkMatcher(address[] memory _matcher) public view returns (bool){\n\n        // we iterate through the matcherarray, the length is defined by the maxMatcherPerAsset-parameter of the Coo-contract or the array-length if it's shorter\n        for(uint i = 0; i < ( AssetContractLookupInterface(assetContractLookup).maxMatcherPerAsset() < _matcher.length? AssetContractLookupInterface(assetContractLookup).maxMatcherPerAsset():_matcher.length); i++){\n            if(_matcher[i] == msg.sender) return true;\n        }\n    }\n\n    /**\n        internal functions\n     */\n    /// @notice function to check whether the provided address is a contract\n    /// @param _address the address to be checked\n    /// @return true when the address has some bytecode\n    function isContract(address _address) internal view returns (bool) {\n        uint size;\n        assembly { size := extcodesize(_address) }\n        return size > 0;\n    }\n\n    /// @notice checks the transfer requirements\n    /// @param _from sender/owner of the entity\n    /// @param _to receiver / new owner of the entity\n    /// @param _entityId the entity-id\n    function simpleTransferInternal(\n        address _from,\n        address _to,\n        uint256 _entityId\n    )\n        internal\n    {\n        TradableEntityContract.TradableEntity memory te = TradableEntityDB(address(db)).getTradableEntity(_entityId);\n\n        require(te.owner == _from,\"not the owner of the entity\");\n        require(te.owner != address(0x0), \"0x0 as owner is not allowed\");\n        require(msg.value == 0, \"sending value is not allowed\");\n      //  require((te.owner == _from) && (te.owner != 0x0) && (msg.value == 0),\"owner not matching or send value\");\n        require(te.owner == msg.sender\n            || checkMatcher(te.escrow)\n            || db.getOwnerToOperators(te.owner, msg.sender)\n            || te.approvedAddress == msg.sender,\"simpleTransfer, missing rights\");\n        db.setTradableEntityOwnerAndAddApproval(_entityId, _to,address(0x0));\n        db.removeTokenAndPrice(_entityId);\n        emit Transfer(_from,_to,_entityId);\n\n    }\n\n    /// @notice checks requirements for a safe transder\n    /// @param _from sender/owner of the entity\n    /// @param _to receiver / new owner of the entity\n    /// @param _entityId the entity-id\n    /// @param _data calldata to be passed\n    function safeTransferChecks(\n        address _from,\n        address _to,\n        uint256 _entityId,\n        bytes memory _data\n    )\n        internal\n    {\n        require(isContract(_to),\"_to is not a contract\");\n        require(ERC721TokenReceiver(_to).onERC721Received(address(this),_from,_entityId,_data) == 0x150b7a02,\"_to did not respond correctly\");\n    }\n\n}\n", "networks": "{}" }
