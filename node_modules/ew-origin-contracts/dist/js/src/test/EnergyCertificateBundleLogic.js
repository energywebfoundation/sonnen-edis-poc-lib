"use strict";
// Copyright 2018 Energy Web Foundation
// This file is part of the Origin Application brought to you by the Energy Web Foundation,
// a global non-profit organization focused on accelerating blockchain technology across the energy sector,
// incorporated in Zug, Switzerland.
//
// The Origin Application is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// This is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY and without an implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details, at <http://www.gnu.org/licenses/>.
//
// @authors: slock.it GmbH; Martin Kuechler, martin.kuchler@slock.it; Heiko Burkhardt, heiko.burkhardt@slock.it;
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const fs = __importStar(require("fs"));
require("mocha");
const ew_user_registry_contracts_1 = require("ew-user-registry-contracts");
const ew_asset_registry_contracts_1 = require("ew-asset-registry-contracts");
const migrateContracts_1 = require("../utils/migrateContracts");
const OriginContractLookup_1 = require("../wrappedContracts/OriginContractLookup");
const TestReceiver_1 = require("../wrappedContracts/TestReceiver");
const EnergyCertificateBundleLogic_1 = require("../wrappedContracts/EnergyCertificateBundleLogic");
const EnergyCertificateBundleDB_1 = require("../wrappedContracts/EnergyCertificateBundleDB");
const Erc20TestToken_1 = require("../wrappedContracts/Erc20TestToken");
const web3_1 = __importDefault(require("web3"));
const Erc20TestToken_json_1 = __importDefault(require("../../contract-build/Erc20TestToken.json"));
const TestReceiver_json_1 = __importDefault(require("../../contract-build/TestReceiver.json"));
const ew_utils_deployment_1 = require("ew-utils-deployment");
const __1 = require("..");
describe.skip('EnergyCertificateBundleLogic', () => {
    let assetRegistryContract;
    let originRegistryContract;
    let energyCertificateBundleLogic;
    let energyCertificateBundleDB;
    let isGanache;
    let userRegistryContract;
    let assetRegistry;
    let userLogic;
    let testreceiver;
    let erc721testReceiverAddress;
    let erc20Test;
    const configFile = JSON.parse(fs.readFileSync(process.cwd() + '/connection-config.json', 'utf8'));
    const web3 = new web3_1.default(configFile.develop.web3);
    const privateKeyDeployment = configFile.develop.deployKey.startsWith('0x') ?
        configFile.develop.deployKey : '0x' + configFile.develop.deployKey;
    const accountDeployment = web3.eth.accounts.privateKeyToAccount(privateKeyDeployment).address;
    const assetOwnerPK = '0xc118b0425221384fe0cbbd093b2a81b1b65d0330810e0792c7059e518cea5383';
    const accountAssetOwner = web3.eth.accounts.privateKeyToAccount(assetOwnerPK).address;
    const traderPK = '0x2dc5120c26df339dbd9861a0f39a79d87e0638d30fdedc938861beac77bbd3f5';
    const accountTrader = web3.eth.accounts.privateKeyToAccount(traderPK).address;
    const assetSmartmeterPK = '0x2dc5120c26df339dbd9861a0f39a79d87e0638d30fdedc938861beac77bbd3f5';
    const assetSmartmeter = web3.eth.accounts.privateKeyToAccount(assetSmartmeterPK).address;
    const matcherPK = '0xd9d5e7a2ebebbad1eb22a63baa739a6c6a6f15d07fcc990ea4dea5c64022a87a';
    const matcherAccount = web3.eth.accounts.privateKeyToAccount(matcherPK).address;
    const approvedPK = '0x7da67da863672d4cc2984e93ce28d98b0d782d8caa43cd1c977b919c0209541b';
    const approvedAccount = web3.eth.accounts.privateKeyToAccount(approvedPK).address;
    describe('init checks', () => {
        it('should deploy the contracts', () => __awaiter(this, void 0, void 0, function* () {
            // isGanache = (await getClientVersion(web3)).includes('EthereumJS');
            const userContracts = yield ew_user_registry_contracts_1.migrateUserRegistryContracts(web3, privateKeyDeployment);
            userLogic = new ew_user_registry_contracts_1.UserLogic(web3, userContracts.UserLogic);
            yield userLogic.setUser(accountDeployment, 'admin', { privateKey: privateKeyDeployment });
            yield userLogic.setRoles(accountDeployment, 3, { privateKey: privateKeyDeployment });
            const userContractLookupAddr = userContracts.UserContractLookup;
            userRegistryContract = new ew_user_registry_contracts_1.UserContractLookup(web3, userContractLookupAddr);
            const assetContracts = yield ew_asset_registry_contracts_1.migrateAssetRegistryContracts(web3, userContractLookupAddr, privateKeyDeployment);
            const assetRegistryLookupAddr = assetContracts.AssetContractLookup;
            const assetProducingAddr = assetContracts.AssetProducingRegistryLogic;
            const originContracts = yield migrateContracts_1.migrateEnergyBundleContracts(web3, assetRegistryLookupAddr, privateKeyDeployment);
            assetRegistryContract = new ew_asset_registry_contracts_1.AssetContractLookup(web3, assetRegistryLookupAddr);
            assetRegistry = new ew_asset_registry_contracts_1.AssetProducingRegistryLogic(web3, assetProducingAddr);
            // originRegistryContract = new OriginContractLookup((web3 as any));
            // certificateLogic = new CertificateLogic((web3 as any));
            // certificateDB = new CertificateDB((web3 as any));
            // assetRegistry = new AssetProducingRegistryLogic((web3 as any), assetProducingAddr);
            Object.keys(originContracts).forEach((key) => __awaiter(this, void 0, void 0, function* () {
                let tempBytecode;
                if (key.includes('OriginContractLookup')) {
                    originRegistryContract = new OriginContractLookup_1.OriginContractLookup(web3, originContracts[key]);
                    tempBytecode = '0x' + __1.OriginContractLookupJSON.deployedBytecode;
                }
                if (key.includes('EnergyCertificateBundleLogic')) {
                    energyCertificateBundleLogic = new EnergyCertificateBundleLogic_1.EnergyCertificateBundleLogic(web3, originContracts[key]);
                    tempBytecode = '0x' + __1.EnergyCertificateBundleLogicJSON.deployedBytecode;
                }
                if (key.includes('EnergyCertificateBundleDB')) {
                    energyCertificateBundleDB = new EnergyCertificateBundleDB_1.EnergyCertificateBundleDB(web3, originContracts[key]);
                    tempBytecode = '0x' + __1.EnergyCertificateBundleDBJSON.deployedBytecode;
                }
                const deployedBytecode = yield web3.eth.getCode(originContracts[key]);
                chai_1.assert.isTrue(deployedBytecode.length > 0);
                chai_1.assert.equal(deployedBytecode, tempBytecode);
            }));
        }));
        it('should deploy a testtoken contracts', () => __awaiter(this, void 0, void 0, function* () {
            erc721testReceiverAddress = (yield ew_utils_deployment_1.deploy(web3, TestReceiver_json_1.default.bytecode + web3.eth.abi.encodeParameter('address', energyCertificateBundleLogic.web3Contract.options.address).substr(2), {
                privateKey: privateKeyDeployment,
            })).contractAddress;
            const erc20testContractAddress = (yield ew_utils_deployment_1.deploy(web3, Erc20TestToken_json_1.default.bytecode + web3.eth.abi.encodeParameter('address', accountTrader).substr(2), {
                privateKey: privateKeyDeployment,
            })).contractAddress;
            testreceiver = new TestReceiver_1.TestReceiver(web3, erc721testReceiverAddress);
            erc20Test = new Erc20TestToken_1.Erc20TestToken(web3, erc20testContractAddress);
        }));
        it('should have the right owner', () => __awaiter(this, void 0, void 0, function* () {
            chai_1.assert.equal(yield energyCertificateBundleLogic.owner(), originRegistryContract.web3Contract._address);
        }));
        it('should have the lookup-contracts', () => __awaiter(this, void 0, void 0, function* () {
            // tslint:disable-next-line:max-line-length
            chai_1.assert.equal(yield energyCertificateBundleLogic.assetContractLookup(), assetRegistryContract.web3Contract._address);
            chai_1.assert.equal(yield energyCertificateBundleLogic.userContractLookup(), userRegistryContract.web3Contract._address);
        }));
        it('should the correct DB', () => __awaiter(this, void 0, void 0, function* () {
            chai_1.assert.equal(yield energyCertificateBundleLogic.db(), energyCertificateBundleDB.web3Contract._address);
        }));
        it('should have balances of 0', () => __awaiter(this, void 0, void 0, function* () {
            chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountDeployment), 0);
            chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountAssetOwner), 0);
            chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountTrader), 0);
        }));
        it('should throw for balance of address 0x0', () => __awaiter(this, void 0, void 0, function* () {
            let failed = false;
            try {
                yield energyCertificateBundleLogic.balanceOf('0x0000000000000000000000000000000000000000');
            }
            catch (ex) {
                failed = true;
            }
            chai_1.assert.isTrue(failed);
        }));
        it('should throw when trying to access a non existing certificate', () => __awaiter(this, void 0, void 0, function* () {
            let failed = false;
            try {
                yield energyCertificateBundleLogic.ownerOf(0);
            }
            catch (ex) {
                failed = true;
            }
            chai_1.assert.isTrue(failed);
        }));
        it('should throw when trying to call safeTransferFrom a non existing certificate', () => __awaiter(this, void 0, void 0, function* () {
            let failed = false;
            try {
                yield energyCertificateBundleLogic.safeTransferFrom(accountDeployment, accountTrader, 0, '0x00', { privateKey: privateKeyDeployment });
            }
            catch (ex) {
                failed = true;
            }
            chai_1.assert.isTrue(failed);
        }));
        it('should throw when trying to call safeTransferFrom a non existing certificate', () => __awaiter(this, void 0, void 0, function* () {
            let failed = false;
            try {
                yield energyCertificateBundleLogic.safeTransferFrom(accountDeployment, accountTrader, 0, { privateKey: privateKeyDeployment });
            }
            catch (ex) {
                failed = true;
            }
            chai_1.assert.isTrue(failed);
        }));
        it('should throw when trying to call transferFrom a non existing certificate', () => __awaiter(this, void 0, void 0, function* () {
            let failed = false;
            try {
                yield energyCertificateBundleLogic.transferFrom(accountDeployment, accountTrader, 0, { privateKey: privateKeyDeployment });
            }
            catch (ex) {
                failed = true;
            }
            chai_1.assert.isTrue(failed);
        }));
        it('should throw when trying to call approve a non existing certificate', () => __awaiter(this, void 0, void 0, function* () {
            let failed = false;
            try {
                yield energyCertificateBundleLogic.approve(accountTrader, 0, { privateKey: privateKeyDeployment });
            }
            catch (ex) {
                failed = true;
            }
            chai_1.assert.isTrue(failed);
        }));
        it('should set right roles to users', () => __awaiter(this, void 0, void 0, function* () {
            yield userLogic.setUser(accountTrader, 'trader', { privateKey: privateKeyDeployment });
            yield userLogic.setUser(accountAssetOwner, 'assetOwner', { privateKey: privateKeyDeployment });
            //   await userLogic.setUser(testreceiver.web3Contract._address, 'testreceiver', { privateKey: privateKeyDeployment });
            // await userLogic.setRoles(testreceiver.web3Contract._address, 16, { privateKey: privateKeyDeployment });
            yield userLogic.setRoles(accountTrader, 16, { privateKey: privateKeyDeployment });
            yield userLogic.setRoles(accountAssetOwner, 24, { privateKey: privateKeyDeployment });
        }));
        it('should onboard an asset', () => __awaiter(this, void 0, void 0, function* () {
            yield assetRegistry.createAsset(assetSmartmeter, accountAssetOwner, true, ["0x1000000000000000000000000000000000000005"], 'propertiesDocumentHash', 'url', 2, {
                privateKey: privateKeyDeployment,
            });
        }));
        it('should set MarketLogicAddress', () => __awaiter(this, void 0, void 0, function* () {
            yield assetRegistry.setMarketLookupContract(0, originRegistryContract.web3Contract._address, { privateKey: assetOwnerPK });
            chai_1.assert.equal(yield assetRegistry.getMarketLookupContract(0), originRegistryContract.web3Contract._address);
        }));
        it('should enable bundle', () => __awaiter(this, void 0, void 0, function* () {
            yield assetRegistry.setBundleActive(0, true, { privateKey: assetOwnerPK });
        }));
        it('should return right interface', () => __awaiter(this, void 0, void 0, function* () {
            chai_1.assert.isTrue(yield energyCertificateBundleLogic.supportsInterface('0x80ac58cd'));
            chai_1.assert.isFalse(yield energyCertificateBundleLogic.supportsInterface('0x80ac58c1'));
        }));
        describe('transferFrom', () => {
            it('should have 0 certificates', () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.equal(yield energyCertificateBundleLogic.getBundleListLength(), 0);
            }));
            it('should log energy', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield assetRegistry.saveSmartMeterRead(0, 100, 'lastSmartMeterReadFileHash', { privateKey: assetSmartmeterPK });
                const event = (yield assetRegistry.getAllLogNewMeterReadEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber }))[0];
                chai_1.assert.equal(event.event, 'LogNewMeterRead');
                chai_1.assert.deepEqual(event.returnValues, {
                    0: '0',
                    1: '0',
                    2: '100',
                    _assetId: '0',
                    _oldMeterRead: '0',
                    _newMeterRead: '100'
                });
                if (isGanache) {
                    const allTransferEvents = yield energyCertificateBundleLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                    chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                        0: '0x0000000000000000000000000000000000000000',
                        1: accountAssetOwner,
                        2: '0',
                        _from: '0x0000000000000000000000000000000000000000',
                        _to: accountAssetOwner,
                        _tokenId: '0',
                    });
                }
            }));
            it('should have 1 certificate', () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.equal(yield energyCertificateBundleLogic.getBundleListLength(), 1);
            }));
            it('should return the bundle', () => __awaiter(this, void 0, void 0, function* () {
                const bundle = yield energyCertificateBundleLogic.getBundle(0);
                const bundleSpecific = bundle.certificateSpecific;
                chai_1.assert.isFalse(bundleSpecific.retired);
                chai_1.assert.equal(bundleSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(bundleSpecific.parentId, 0);
                chai_1.assert.equal(bundleSpecific.children.length, 0);
                chai_1.assert.equal(bundleSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(bundleSpecific.ownerChangeCounter, 0);
                const tradableEntity = bundle.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, ['0x1000000000000000000000000000000000000005']);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should have a balance of 1 for assetOwner address', () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountTrader), 0);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountAssetOwner), 1);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountDeployment), 0);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(matcherAccount), 0);
            }));
            it('should return the correct owner', () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.equal(yield energyCertificateBundleLogic.ownerOf(0), accountAssetOwner);
            }));
            it('should return correct approvedFor', () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.equal(yield energyCertificateBundleLogic.getApproved(0), '0x0000000000000000000000000000000000000000');
            }));
            it('should return correct isApprovedForAll', () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.isFalse(yield energyCertificateBundleLogic.isApprovedForAll(accountAssetOwner, accountDeployment));
                chai_1.assert.isFalse(yield energyCertificateBundleLogic.isApprovedForAll(accountAssetOwner, accountTrader));
                chai_1.assert.isFalse(yield energyCertificateBundleLogic.isApprovedForAll(accountAssetOwner, matcherAccount));
            }));
            it('should throw when trying to call transferFrom as an admin that does not own that', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.transferFrom(accountAssetOwner, accountTrader, 0, { privateKey: privateKeyDeployment });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'simpleTransfer, missing rights');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call transferFrom as an trader that does not own that', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.transferFrom(accountAssetOwner, accountTrader, 0, { privateKey: traderPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'simpleTransfer, missing rights');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call transferFrom using wrong _from', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.transferFrom(accountDeployment, accountTrader, 1, { privateKey: assetOwnerPK });
                }
                catch (ex) {
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should be able to do transferFrom', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield energyCertificateBundleLogic.transferFrom(accountAssetOwner, accountTrader, 0, { privateKey: assetOwnerPK });
                chai_1.assert.equal(yield energyCertificateBundleLogic.getBundleListLength(), 1);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountTrader), 1);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountAssetOwner), 0);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountDeployment), 0);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(matcherAccount), 0);
                if (isGanache) {
                    const allEvents = yield energyCertificateBundleLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                    chai_1.assert.equal(allEvents.length, 1);
                    chai_1.assert.equal(allEvents[0].event, 'Transfer');
                    chai_1.assert.deepEqual(allEvents[0].returnValues, {
                        0: accountAssetOwner,
                        1: accountTrader,
                        2: '0',
                        _from: accountAssetOwner,
                        _to: accountTrader,
                        _tokenId: '0',
                    });
                }
            }));
            it('should return the bundle again ', () => __awaiter(this, void 0, void 0, function* () {
                const bundle = yield energyCertificateBundleLogic.getBundle(0);
                const bundleSpecific = bundle.certificateSpecific;
                chai_1.assert.isFalse(bundleSpecific.retired);
                chai_1.assert.equal(bundleSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(bundleSpecific.parentId, 0);
                chai_1.assert.equal(bundleSpecific.children.length, 0);
                chai_1.assert.equal(bundleSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(bundleSpecific.ownerChangeCounter, 1);
                const tradableEntity = bundle.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountTrader);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, []);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should throw when trying to call transferFrom as an admin that does not own that', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.transferFrom(accountTrader, accountTrader, 0, { privateKey: privateKeyDeployment });
                }
                catch (ex) {
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call transferFrom as an assetOwner that does not own that', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.transferFrom(accountTrader, accountTrader, 0, { privateKey: assetOwnerPK });
                }
                catch (ex) {
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call transferFrom using wrong _from', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.transferFrom(accountDeployment, accountTrader, 1, { privateKey: traderPK });
                }
                catch (ex) {
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should be able to do transferFrom again', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield energyCertificateBundleLogic.transferFrom(accountTrader, accountTrader, 0, { privateKey: traderPK });
                chai_1.assert.equal(yield energyCertificateBundleLogic.getBundleListLength(), 1);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountTrader), 1);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountAssetOwner), 0);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountDeployment), 0);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(matcherAccount), 0);
                if (isGanache) {
                    const allEvents = yield energyCertificateBundleLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                    chai_1.assert.equal(allEvents.length, 1);
                    chai_1.assert.equal(allEvents[0].event, 'Transfer');
                    chai_1.assert.deepEqual(allEvents[0].returnValues, {
                        0: accountTrader,
                        1: accountTrader,
                        2: '0',
                        _from: accountTrader,
                        _to: accountTrader,
                        _tokenId: '0',
                    });
                    const retireEvent = yield energyCertificateBundleLogic.getAllLogBundleRetiredEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                    chai_1.assert.equal(retireEvent.length, 1);
                    chai_1.assert.equal(retireEvent[0].event, 'LogBundleRetired');
                    chai_1.assert.deepEqual(retireEvent[0].returnValues, {
                        0: '0', 1: true, _bundleId: '0', _retire: true,
                    });
                }
            }));
            it('should return the bundle again ', () => __awaiter(this, void 0, void 0, function* () {
                const bundle = yield energyCertificateBundleLogic.getBundle(0);
                const bundleSpecific = bundle.certificateSpecific;
                chai_1.assert.isTrue(bundleSpecific.retired);
                chai_1.assert.equal(bundleSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(bundleSpecific.parentId, 0);
                chai_1.assert.equal(bundleSpecific.children.length, 0);
                chai_1.assert.equal(bundleSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(bundleSpecific.ownerChangeCounter, 2);
                const tradableEntity = bundle.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountTrader);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, []);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should throw when trying to call transferFrom on a retired certificate as trader', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.transferFrom(accountTrader, accountTrader, 1, { privateKey: traderPK });
                }
                catch (ex) {
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call transferFrom on a retired certificate as admin', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.transferFrom(accountTrader, accountTrader, 1, { privateKey: privateKeyDeployment });
                }
                catch (ex) {
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call transferFrom on a retired certificate as assetOwner', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.transferFrom(accountTrader, accountTrader, 1, { privateKey: assetOwnerPK });
                }
                catch (ex) {
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
        });
        describe('saveTransferFrom without data', () => {
            it('should log energy (Bundle #1)', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield assetRegistry.saveSmartMeterRead(0, 200, 'lastSmartMeterReadFileHash', { privateKey: assetSmartmeterPK });
                const event = (yield assetRegistry.getAllLogNewMeterReadEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber }))[0];
                chai_1.assert.equal(event.event, 'LogNewMeterRead');
                chai_1.assert.deepEqual(event.returnValues, {
                    0: '0',
                    1: '100',
                    2: '200',
                    _assetId: '0',
                    _oldMeterRead: '100',
                    _newMeterRead: '200'
                });
                if (isGanache) {
                    const allTransferEvents = yield energyCertificateBundleLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                    chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                        0: '0x0000000000000000000000000000000000000000',
                        1: accountAssetOwner,
                        2: '1',
                        _from: '0x0000000000000000000000000000000000000000',
                        _to: accountAssetOwner,
                        _tokenId: '1',
                    });
                }
            }));
            it('should return the bundle #1', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield energyCertificateBundleLogic.getBundle(1);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 1);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 0);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, ['0x1000000000000000000000000000000000000005']);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should throw when trying to call safeTransferFrom to a regular address as admin', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, accountTrader, 1, null, { privateKey: privateKeyDeployment });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'user does not have the required role');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call safeTransferFrom to a regular address as trader', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, accountTrader, 1, null, { privateKey: traderPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'simpleTransfer, missing rights');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call safeTransferFrom to a regular address as owner', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, accountTrader, 1, null, { privateKey: assetOwnerPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, '_to is not a contract');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call safeTransferFrom to a contract without specific funcion as admin', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, energyCertificateBundleLogic.web3Contract._address, 1, null, { privateKey: privateKeyDeployment });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'user does not have the required role');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call safeTransferFrom to a contract without specific funcion as trader', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, energyCertificateBundleLogic.web3Contract._address, 1, null, { privateKey: traderPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'simpleTransfer, missing rights');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call safeTransferFrom to a contract without specific funcion as trader', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, energyCertificateBundleLogic.web3Contract._address, 1, null, { privateKey: assetOwnerPK });
                }
                catch (ex) {
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call safeTransferFrom to a correct receiver as admin', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, testreceiver.web3Contract._address, 1, null, { privateKey: privateKeyDeployment });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'user does not have the required role');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call safeTransferFrom to a contract without specific funcion as trader', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, testreceiver.web3Contract._address, 1, null, { privateKey: traderPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'simpleTransfer, missing rights');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should call safetransferFrom as assetManager and correct receiver ', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, testreceiver.web3Contract._address, 1, null, { privateKey: assetOwnerPK });
                if (isGanache) {
                    const allTransferEvents = yield energyCertificateBundleLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                    chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                        0: accountAssetOwner,
                        1: testreceiver.web3Contract._address,
                        2: '1',
                        _from: accountAssetOwner,
                        _to: testreceiver.web3Contract._address,
                        _tokenId: '1',
                    });
                }
                chai_1.assert.equal(yield energyCertificateBundleLogic.getBundleListLength(), 2);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountAssetOwner), 0);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountTrader), 1);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(testreceiver.web3Contract._address), 1);
            }));
        });
        describe('saveTransferFrom with data', () => {
            it('should log energy (Bundle #2)', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield assetRegistry.saveSmartMeterRead(0, 300, 'lastSmartMeterReadFileHash', { privateKey: assetSmartmeterPK });
                const event = (yield assetRegistry.getAllLogNewMeterReadEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber }))[0];
                chai_1.assert.equal(event.event, 'LogNewMeterRead');
                chai_1.assert.deepEqual(event.returnValues, {
                    0: '0',
                    1: '200',
                    2: '300',
                    _assetId: '0',
                    _oldMeterRead: '200',
                    _newMeterRead: '300'
                });
                if (isGanache) {
                    const allTransferEvents = yield energyCertificateBundleLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                    chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                        0: '0x0000000000000000000000000000000000000000',
                        1: accountAssetOwner,
                        2: '2',
                        _from: '0x0000000000000000000000000000000000000000',
                        _to: accountAssetOwner,
                        _tokenId: '2',
                    });
                }
                chai_1.assert.equal(yield energyCertificateBundleLogic.getBundleListLength(), 3);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountAssetOwner), 1);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountTrader), 1);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(testreceiver.web3Contract._address), 1);
            }));
            it('should return the bundle #2', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield energyCertificateBundleLogic.getBundle(2);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 2);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 0);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, ['0x1000000000000000000000000000000000000005']);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should throw when trying to call safeTransferFrom to a regular address as admin', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, accountTrader, 2, '0x01', { privateKey: privateKeyDeployment });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'user does not have the required role');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call safeTransferFrom to a regular address as trader', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, accountTrader, 2, '0x01', { privateKey: traderPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'simpleTransfer, missing rights');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call safeTransferFrom to a regular address as owner', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, accountTrader, 2, '0x01', { privateKey: assetOwnerPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, '_to is not a contract');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call safeTransferFrom to a contract without specific funcion as admin', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, energyCertificateBundleLogic.web3Contract._address, 2, '0x01', { privateKey: privateKeyDeployment });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'user does not have the required role');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call safeTransferFrom to a contract without specific funcion as trader', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, energyCertificateBundleLogic.web3Contract._address, 2, '0x01', { privateKey: traderPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'simpleTransfer, missing rights');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call safeTransferFrom to a contract without specific funcion as trader', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, energyCertificateBundleLogic.web3Contract._address, 2, '0x01', { privateKey: assetOwnerPK });
                }
                catch (ex) {
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call safeTransferFrom to a correct receiver as admin', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, testreceiver.web3Contract._address, 2, '0x01', { privateKey: privateKeyDeployment });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'user does not have the required role');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call safeTransferFrom to a contract without specific funcion as trader', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, testreceiver.web3Contract._address, 2, '0x01', { privateKey: traderPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'simpleTransfer, missing rights');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should call safetransferFrom as assetManager and correct receiver ', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, testreceiver.web3Contract._address, 2, '0x01', { privateKey: assetOwnerPK });
                if (isGanache) {
                    const allTransferEvents = yield energyCertificateBundleLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                    chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                        0: accountAssetOwner,
                        1: testreceiver.web3Contract._address,
                        2: '2',
                        _from: accountAssetOwner,
                        _to: testreceiver.web3Contract._address,
                        _tokenId: '2',
                    });
                }
                chai_1.assert.equal(yield energyCertificateBundleLogic.getBundleListLength(), 3);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountAssetOwner), 0);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountTrader), 1);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(testreceiver.web3Contract._address), 2);
            }));
        });
        describe('escrow and approval', () => {
            /*
            it('should set an escrow to the asset', async () => {
                await assetRegistry.addMatcher(0, matcherAccount, { privateKey: assetOwnerPK });
                assert.deepEqual(await assetRegistry.getMatcher(0),
                                 ['0x1000000000000000000000000000000000000005', matcherAccount]);
            });
            */
            it('should return correct approval', () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.isFalse(yield energyCertificateBundleLogic.isApprovedForAll(accountAssetOwner, approvedAccount));
                chai_1.assert.isFalse(yield energyCertificateBundleLogic.isApprovedForAll(accountTrader, approvedAccount));
                const tx = yield energyCertificateBundleLogic.setApprovalForAll(approvedAccount, true, { privateKey: assetOwnerPK });
                chai_1.assert.isTrue(yield energyCertificateBundleLogic.isApprovedForAll(accountAssetOwner, approvedAccount));
                chai_1.assert.isFalse(yield energyCertificateBundleLogic.isApprovedForAll(accountTrader, approvedAccount));
                const allApprovalEvents = yield energyCertificateBundleLogic.getAllApprovalForAllEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allApprovalEvents.length, 1);
                chai_1.assert.equal(allApprovalEvents[0].event, 'ApprovalForAll');
                chai_1.assert.deepEqual(allApprovalEvents[0].returnValues, {
                    0: accountAssetOwner,
                    1: approvedAccount,
                    2: true,
                    _owner: accountAssetOwner,
                    _operator: approvedAccount,
                    _approved: true,
                });
            }));
            it('should add 2nd approval', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield energyCertificateBundleLogic.setApprovalForAll('0x1000000000000000000000000000000000000005', true, { privateKey: assetOwnerPK });
                const allApprovalEvents = yield energyCertificateBundleLogic.getAllApprovalForAllEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allApprovalEvents.length, 1);
                chai_1.assert.equal(allApprovalEvents[0].event, 'ApprovalForAll');
                chai_1.assert.deepEqual(allApprovalEvents[0].returnValues, {
                    0: accountAssetOwner,
                    1: '0x1000000000000000000000000000000000000005',
                    2: true,
                    _owner: accountAssetOwner,
                    _operator: '0x1000000000000000000000000000000000000005',
                    _approved: true,
                });
                chai_1.assert.isTrue(yield energyCertificateBundleLogic.isApprovedForAll(accountAssetOwner, approvedAccount));
                chai_1.assert.isTrue(yield energyCertificateBundleLogic.isApprovedForAll(accountAssetOwner, '0x1000000000000000000000000000000000000005'));
            }));
            it('should remove approval', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield energyCertificateBundleLogic.setApprovalForAll('0x1000000000000000000000000000000000000005', false, { privateKey: assetOwnerPK });
                const allApprovalEvents = yield energyCertificateBundleLogic.getAllApprovalForAllEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allApprovalEvents.length, 1);
                chai_1.assert.equal(allApprovalEvents[0].event, 'ApprovalForAll');
                chai_1.assert.deepEqual(allApprovalEvents[0].returnValues, {
                    0: accountAssetOwner,
                    1: '0x1000000000000000000000000000000000000005',
                    2: false,
                    _owner: accountAssetOwner,
                    _operator: '0x1000000000000000000000000000000000000005',
                    _approved: false,
                });
                chai_1.assert.isTrue(yield energyCertificateBundleLogic.isApprovedForAll(accountAssetOwner, approvedAccount));
                chai_1.assert.isFalse(yield energyCertificateBundleLogic.isApprovedForAll(accountAssetOwner, '0x1000000000000000000000000000000000000005'));
            }));
            it('should log energy (Bundle #3)', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield assetRegistry.saveSmartMeterRead(0, 400, 'lastSmartMeterReadFileHash', { privateKey: assetSmartmeterPK });
                const event = (yield assetRegistry.getAllLogNewMeterReadEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber }))[0];
                chai_1.assert.equal(event.event, 'LogNewMeterRead');
                chai_1.assert.deepEqual(event.returnValues, {
                    0: '0',
                    1: '300',
                    2: '400',
                    _assetId: '0',
                    _oldMeterRead: '300',
                    _newMeterRead: '400',
                });
                if (isGanache) {
                    const allTransferEvents = yield energyCertificateBundleLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                    chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                        0: '0x0000000000000000000000000000000000000000',
                        1: accountAssetOwner,
                        2: '3',
                        _from: '0x0000000000000000000000000000000000000000',
                        _to: accountAssetOwner,
                        _tokenId: '3',
                    });
                }
                chai_1.assert.equal(yield energyCertificateBundleLogic.getBundleListLength(), 4);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountAssetOwner), 1);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountTrader), 1);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(testreceiver.web3Contract._address), 2);
            }));
            it('should return the bundle #3', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield energyCertificateBundleLogic.getBundle(3);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 3);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 0);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, ['0x1000000000000000000000000000000000000005']);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should return correct getApproved', () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.equal(yield energyCertificateBundleLogic.getApproved(0), '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(yield energyCertificateBundleLogic.getApproved(1), '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(yield energyCertificateBundleLogic.getApproved(2), '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(yield energyCertificateBundleLogic.getApproved(3), '0x0000000000000000000000000000000000000000');
                yield energyCertificateBundleLogic.approve('0x1000000000000000000000000000000000000005', 3, { privateKey: assetOwnerPK });
                chai_1.assert.equal(yield energyCertificateBundleLogic.getApproved(0), '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(yield energyCertificateBundleLogic.getApproved(1), '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(yield energyCertificateBundleLogic.getApproved(2), '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(yield energyCertificateBundleLogic.getApproved(3), '0x1000000000000000000000000000000000000005');
            }));
            it('should throw when calling getApproved for a non valid token', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.getApproved(4);
                }
                catch (ex) {
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when calling approve as admin', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.approve('0x1000000000000000000000000000000000000005', 3, { privateKey: privateKeyDeployment });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'approve: not owner / matcher');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when calling approve as trader', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.approve('0x1000000000000000000000000000000000000005', 3, { privateKey: traderPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'approve: not owner / matcher');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should set an escrow to the asset', () => __awaiter(this, void 0, void 0, function* () {
                yield assetRegistry.addMatcher(0, matcherAccount, { privateKey: assetOwnerPK });
                chai_1.assert.deepEqual(yield assetRegistry.getMatcher(0), ['0x1000000000000000000000000000000000000005', matcherAccount]);
            }));
            it('should throw trying to transfer old certificate with new matcher', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.transferFrom(accountAssetOwner, accountTrader, 3, { privateKey: matcherPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'simpleTransfer, missing rights');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should log energy (Bundle #4)', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield assetRegistry.saveSmartMeterRead(0, 500, 'lastSmartMeterReadFileHash', { privateKey: assetSmartmeterPK });
                const event = (yield assetRegistry.getAllLogNewMeterReadEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber }))[0];
                chai_1.assert.equal(event.event, 'LogNewMeterRead');
                chai_1.assert.deepEqual(event.returnValues, {
                    0: '0',
                    1: '400',
                    2: '500',
                    _assetId: '0',
                    _oldMeterRead: '400',
                    _newMeterRead: '500',
                });
                if (isGanache) {
                    const allTransferEvents = yield energyCertificateBundleLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                    chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                        0: '0x0000000000000000000000000000000000000000',
                        1: accountAssetOwner,
                        2: '4',
                        _from: '0x0000000000000000000000000000000000000000',
                        _to: accountAssetOwner,
                        _tokenId: '4',
                    });
                }
                chai_1.assert.equal(yield energyCertificateBundleLogic.getBundleListLength(), 5);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountAssetOwner), 2);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountTrader), 1);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(testreceiver.web3Contract._address), 2);
            }));
            it('should return the bundle #4', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield energyCertificateBundleLogic.getBundle(4);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 4);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 0);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, ['0x1000000000000000000000000000000000000005', matcherAccount]);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            /*
            it('should set matcherAccount roles', async () => {
                await userLogic.setUser(matcherAccount, 'matcherAccount', { privateKey: privateKeyDeployment });
                await userLogic.setRoles(matcherAccount, 16, { privateKey: privateKeyDeployment });
            });
            */
            it('should transfer certificate#4 with new matcher', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield energyCertificateBundleLogic.transferFrom(accountAssetOwner, accountTrader, 4, { privateKey: matcherPK });
                if (isGanache) {
                    const allTransferEvents = yield energyCertificateBundleLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                    chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                        0: accountAssetOwner,
                        1: accountTrader,
                        2: '4',
                        _from: accountAssetOwner,
                        _to: accountTrader,
                        _tokenId: '4',
                    });
                }
                chai_1.assert.equal(yield energyCertificateBundleLogic.getBundleListLength(), 5);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountAssetOwner), 1);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountTrader), 2);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(testreceiver.web3Contract._address), 2);
            }));
            it('should log energy (Bundle #5)', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield assetRegistry.saveSmartMeterRead(0, 600, 'lastSmartMeterReadFileHash', { privateKey: assetSmartmeterPK });
                const event = (yield assetRegistry.getAllLogNewMeterReadEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber }))[0];
                chai_1.assert.equal(event.event, 'LogNewMeterRead');
                chai_1.assert.deepEqual(event.returnValues, {
                    0: '0',
                    1: '500',
                    2: '600',
                    _assetId: '0',
                    _oldMeterRead: '500',
                    _newMeterRead: '600',
                });
                if (isGanache) {
                    const allTransferEvents = yield energyCertificateBundleLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                    chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                        0: '0x0000000000000000000000000000000000000000',
                        1: accountAssetOwner,
                        2: '5',
                        _from: '0x0000000000000000000000000000000000000000',
                        _to: accountAssetOwner,
                        _tokenId: '5',
                    });
                }
                chai_1.assert.equal(yield energyCertificateBundleLogic.getBundleListLength(), 6);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountAssetOwner), 2);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountTrader), 2);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(testreceiver.web3Contract._address), 2);
            }));
            it('should return the bundle #5', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield energyCertificateBundleLogic.getBundle(5);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 5);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 0);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, ['0x1000000000000000000000000000000000000005', matcherAccount]);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should throw trying to call safeTransferFrom certificate#3 without data and new matcher to an address', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, accountTrader, 3, null, { privateKey: matcherPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'user does not have the required role');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw trying to call safeTransferFrom certificate#3 without data and new matcher to an a regular contract', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, energyCertificateBundleLogic.web3Contract._address, 3, null, { privateKey: matcherPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'user does not have the required role');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw trying to call safeTransferFrom certificate#3 without data and new matcher to an receiver contract', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, testreceiver.web3Contract._address, 3, null, { privateKey: matcherPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'user does not have the required role');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw trying to call safeTransferFrom certificate#3 without data and new matcher to an address', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, accountTrader, 5, null, { privateKey: matcherPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'user does not have the required role');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw trying to call safeTransferFrom certificate#3 without data and new matcher to an a regular contract', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, energyCertificateBundleLogic.web3Contract._address, 5, null, { privateKey: matcherPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'user does not have the required role');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should reset matcherAccount roles to 0', () => __awaiter(this, void 0, void 0, function* () {
                yield userLogic.setUser(matcherAccount, 'matcherAccount', { privateKey: privateKeyDeployment });
                yield userLogic.setRoles(matcherAccount, 0, { privateKey: privateKeyDeployment });
            }));
            it('should throw trying to call safeTransferFrom certificate#3 without data and new matcher to an a regular contract', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, testreceiver.web3Contract._address, 5, null, { privateKey: matcherPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'user does not have the required role');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should reset matcherAccount roles to trader', () => __awaiter(this, void 0, void 0, function* () {
                yield userLogic.setUser(matcherAccount, 'matcherAccount', { privateKey: privateKeyDeployment });
                yield userLogic.setRoles(matcherAccount, 16, { privateKey: privateKeyDeployment });
            }));
            it('should transfer certificate#5 with new matcher', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, testreceiver.web3Contract._address, 5, null, { privateKey: matcherPK });
                if (isGanache) {
                    const allTransferEvents = yield energyCertificateBundleLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                    chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                        0: accountAssetOwner,
                        1: testreceiver.web3Contract._address,
                        2: '5',
                        _from: accountAssetOwner,
                        _to: testreceiver.web3Contract._address,
                        _tokenId: '5',
                    });
                }
                chai_1.assert.equal(yield energyCertificateBundleLogic.getBundleListLength(), 6);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountAssetOwner), 1);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountTrader), 2);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(testreceiver.web3Contract._address), 3);
            }));
            it('should return the bundle #5', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield energyCertificateBundleLogic.getBundle(5);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 5);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 1);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, testreceiver.web3Contract._address);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, []);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should log energy (Bundle #6)', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield assetRegistry.saveSmartMeterRead(0, 700, 'lastSmartMeterReadFileHash', { privateKey: assetSmartmeterPK });
                const event = (yield assetRegistry.getAllLogNewMeterReadEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber }))[0];
                chai_1.assert.equal(event.event, 'LogNewMeterRead');
                chai_1.assert.deepEqual(event.returnValues, {
                    0: '0',
                    1: '600',
                    2: '700',
                    _assetId: '0',
                    _oldMeterRead: '600',
                    _newMeterRead: '700',
                });
                if (isGanache) {
                    const allTransferEvents = yield energyCertificateBundleLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                    chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                        0: '0x0000000000000000000000000000000000000000',
                        1: accountAssetOwner,
                        2: '6',
                        _from: '0x0000000000000000000000000000000000000000',
                        _to: accountAssetOwner,
                        _tokenId: '6',
                    });
                }
                chai_1.assert.equal(yield energyCertificateBundleLogic.getBundleListLength(), 7);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountAssetOwner), 2);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountTrader), 2);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(testreceiver.web3Contract._address), 3);
            }));
            it('should return the bundle #6', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield energyCertificateBundleLogic.getBundle(6);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 6);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 0);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, ['0x1000000000000000000000000000000000000005', matcherAccount]);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should throw trying to call safeTransferFrom certificate#3 with data and new matcher to an address', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, accountTrader, 3, '0x01', { privateKey: matcherPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'simpleTransfer, missing rights');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw trying to call safeTransferFrom certificate#3 with data and new matcher to an a regular contract', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, energyCertificateBundleLogic.web3Contract._address, 3, '0x01', { privateKey: matcherPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'simpleTransfer, missing rights');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw trying to call safeTransferFrom certificate#3 with data and new matcher to an receiver contract', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, testreceiver.web3Contract._address, 3, '0x01', { privateKey: matcherPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'simpleTransfer, missing rights');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw trying to call safeTransferFrom certificate#3 with data and new matcher to an address', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, accountTrader, 5, '0x01', { privateKey: matcherPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'not the owner of the entity');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw trying to call safeTransferFrom certificate#5 with data and new matcher to an a regular contract', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, energyCertificateBundleLogic.web3Contract._address, 6, '0x01', { privateKey: matcherPK });
                }
                catch (ex) {
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should reset matcherAccount roles to 0', () => __awaiter(this, void 0, void 0, function* () {
                yield userLogic.setUser(matcherAccount, 'matcherAccount', { privateKey: privateKeyDeployment });
                yield userLogic.setRoles(matcherAccount, 0, { privateKey: privateKeyDeployment });
            }));
            it('should throw trying to call safeTransferFrom certificate#3 with data and new matcher to an a regular contract', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, testreceiver.web3Contract._address, 6, '0x01', { privateKey: matcherPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'user does not have the required role');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should reset matcherAccount roles to trader', () => __awaiter(this, void 0, void 0, function* () {
                yield userLogic.setUser(matcherAccount, 'matcherAccount', { privateKey: privateKeyDeployment });
                yield userLogic.setRoles(matcherAccount, 16, { privateKey: privateKeyDeployment });
            }));
            it('should transfer certificate#6 with new matcher', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, testreceiver.web3Contract._address, 6, '0x01', { privateKey: matcherPK });
                if (isGanache) {
                    const allTransferEvents = yield energyCertificateBundleLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                    chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                        0: accountAssetOwner,
                        1: testreceiver.web3Contract._address,
                        2: '6',
                        _from: accountAssetOwner,
                        _to: testreceiver.web3Contract._address,
                        _tokenId: '6',
                    });
                }
                chai_1.assert.equal(yield energyCertificateBundleLogic.getBundleListLength(), 7);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountAssetOwner), 1);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountTrader), 2);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(testreceiver.web3Contract._address), 4);
            }));
            it('should return the bundle #5', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield energyCertificateBundleLogic.getBundle(6);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 6);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 1);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, testreceiver.web3Contract._address);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, []);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should log energy (Bundle #7)', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield assetRegistry.saveSmartMeterRead(0, 800, 'lastSmartMeterReadFileHash', { privateKey: assetSmartmeterPK });
                const event = (yield assetRegistry.getAllLogNewMeterReadEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber }))[0];
                chai_1.assert.equal(event.event, 'LogNewMeterRead');
                chai_1.assert.deepEqual(event.returnValues, {
                    0: '0',
                    1: '700',
                    2: '800',
                    _assetId: '0',
                    _oldMeterRead: '700',
                    _newMeterRead: '800',
                });
                if (isGanache) {
                    const allTransferEvents = yield energyCertificateBundleLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                    chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                        0: '0x0000000000000000000000000000000000000000',
                        1: accountAssetOwner,
                        2: '7',
                        _from: '0x0000000000000000000000000000000000000000',
                        _to: accountAssetOwner,
                        _tokenId: '7',
                    });
                }
                chai_1.assert.equal(yield energyCertificateBundleLogic.getBundleListLength(), 8);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountAssetOwner), 2);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountTrader), 2);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(testreceiver.web3Contract._address), 4);
            }));
            it('should return the bundle #7', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield energyCertificateBundleLogic.getBundle(7);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 7);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 0);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, ['0x1000000000000000000000000000000000000005', matcherAccount]);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should throw when trying to call transferFrom as non approved account', () => __awaiter(this, void 0, void 0, function* () {
                yield energyCertificateBundleLogic.setApprovalForAll(approvedAccount, false, { privateKey: assetOwnerPK });
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.transferFrom(accountAssetOwner, accountTrader, 7, { privateKey: approvedPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'simpleTransfer, missing rights');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should transferFrom as approved account', () => __awaiter(this, void 0, void 0, function* () {
                yield energyCertificateBundleLogic.setApprovalForAll(approvedAccount, true, { privateKey: assetOwnerPK });
                const tx = yield energyCertificateBundleLogic.transferFrom(accountAssetOwner, accountTrader, 7, { privateKey: approvedPK });
                if (isGanache) {
                    const allTransferEvents = yield energyCertificateBundleLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                    chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                        0: accountAssetOwner,
                        1: accountTrader,
                        2: '7',
                        _from: accountAssetOwner,
                        _to: accountTrader,
                        _tokenId: '7',
                    });
                }
                chai_1.assert.equal(yield energyCertificateBundleLogic.getBundleListLength(), 8);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountAssetOwner), 1);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountTrader), 3);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(testreceiver.web3Contract._address), 4);
            }));
            it('should return the bundle #7 again', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield energyCertificateBundleLogic.getBundle(7);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 7);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 1);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountTrader);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, []);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should set role to approved account', () => __awaiter(this, void 0, void 0, function* () {
                yield userLogic.setUser(approvedAccount, 'approvedAccount', { privateKey: privateKeyDeployment });
                yield userLogic.setRoles(approvedAccount, 16, { privateKey: privateKeyDeployment });
            }));
            it('should log energy (Bundle #8)', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield assetRegistry.saveSmartMeterRead(0, 900, 'lastSmartMeterReadFileHash', { privateKey: assetSmartmeterPK });
                const event = (yield assetRegistry.getAllLogNewMeterReadEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber }))[0];
                chai_1.assert.equal(event.event, 'LogNewMeterRead');
                chai_1.assert.deepEqual(event.returnValues, {
                    0: '0',
                    1: '800',
                    2: '900',
                    _assetId: '0',
                    _oldMeterRead: '800',
                    _newMeterRead: '900',
                });
                if (isGanache) {
                    const allTransferEvents = yield energyCertificateBundleLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                    chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                        0: '0x0000000000000000000000000000000000000000',
                        1: accountAssetOwner,
                        2: '8',
                        _from: '0x0000000000000000000000000000000000000000',
                        _to: accountAssetOwner,
                        _tokenId: '8',
                    });
                }
                chai_1.assert.equal(yield energyCertificateBundleLogic.getBundleListLength(), 9);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountAssetOwner), 2);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountTrader), 3);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(testreceiver.web3Contract._address), 4);
            }));
            it('should return the bundle #8', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield energyCertificateBundleLogic.getBundle(8);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 8);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 0);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, ['0x1000000000000000000000000000000000000005', matcherAccount]);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should throw when trying to call safeTransferFrom with no data to regular address as non approved account', () => __awaiter(this, void 0, void 0, function* () {
                yield energyCertificateBundleLogic.setApprovalForAll(approvedAccount, false, { privateKey: assetOwnerPK });
                let failed = false;
                try {
                    const tx = yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, accountTrader, 8, null, { privateKey: approvedPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'simpleTransfer, missing rights');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call safeTransferFrom with no data to random contract address as non approved account', () => __awaiter(this, void 0, void 0, function* () {
                yield energyCertificateBundleLogic.setApprovalForAll(approvedAccount, false, { privateKey: assetOwnerPK });
                let failed = false;
                try {
                    const tx = yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, energyCertificateBundleLogic.web3Contract._address, 8, null, { privateKey: approvedPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'simpleTransfer, missing rights');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call safeTransferFrom with no data to correct contract address as non approved account', () => __awaiter(this, void 0, void 0, function* () {
                yield energyCertificateBundleLogic.setApprovalForAll(approvedAccount, false, { privateKey: assetOwnerPK });
                let failed = false;
                try {
                    const tx = yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, testreceiver.web3Contract._address, 8, null, { privateKey: approvedPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'simpleTransfer, missing rights');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call safeTransferFrom with no data to regular address as approved account', () => __awaiter(this, void 0, void 0, function* () {
                yield energyCertificateBundleLogic.setApprovalForAll(approvedAccount, true, { privateKey: assetOwnerPK });
                let failed = false;
                try {
                    const tx = yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, accountTrader, 8, null, { privateKey: approvedPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, '_to is not a contract');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call safeTransferFrom with no data to random contract address as approved account', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    const tx = yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, energyCertificateBundleLogic.web3Contract._address, 8, null, { privateKey: approvedPK });
                }
                catch (ex) {
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should call safeTransferFrom with no data to correct contract address as approved account', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, testreceiver.web3Contract._address, 8, null, { privateKey: approvedPK });
                if (isGanache) {
                    const allTransferEvents = yield energyCertificateBundleLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                    chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                        0: accountAssetOwner,
                        1: testreceiver.web3Contract._address,
                        2: '8',
                        _from: accountAssetOwner,
                        _to: testreceiver.web3Contract._address,
                        _tokenId: '8',
                    });
                }
                chai_1.assert.equal(yield energyCertificateBundleLogic.getBundleListLength(), 9);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountAssetOwner), 1);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountTrader), 3);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(testreceiver.web3Contract._address), 5);
            }));
            it('should return the bundle #8 again', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield energyCertificateBundleLogic.getBundle(8);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 8);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 1);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, testreceiver.web3Contract._address);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, []);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should log energy (Bundle #9)', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield assetRegistry.saveSmartMeterRead(0, 1000, 'lastSmartMeterReadFileHash', { privateKey: assetSmartmeterPK });
                const event = (yield assetRegistry.getAllLogNewMeterReadEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber }))[0];
                chai_1.assert.equal(event.event, 'LogNewMeterRead');
                chai_1.assert.deepEqual(event.returnValues, {
                    0: '0',
                    1: '900',
                    2: '1000',
                    _assetId: '0',
                    _oldMeterRead: '900',
                    _newMeterRead: '1000',
                });
                if (isGanache) {
                    const allTransferEvents = yield energyCertificateBundleLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                    chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                        0: '0x0000000000000000000000000000000000000000',
                        1: accountAssetOwner,
                        2: '9',
                        _from: '0x0000000000000000000000000000000000000000',
                        _to: accountAssetOwner,
                        _tokenId: '9',
                    });
                }
                chai_1.assert.equal(yield energyCertificateBundleLogic.getBundleListLength(), 10);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountAssetOwner), 2);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountTrader), 3);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(testreceiver.web3Contract._address), 5);
            }));
            it('should return the bundle #9', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield energyCertificateBundleLogic.getBundle(9);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 9);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 0);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, ['0x1000000000000000000000000000000000000005', matcherAccount]);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should throw when trying to call safeTransferFrom with no data to regular address as non approved account', () => __awaiter(this, void 0, void 0, function* () {
                yield energyCertificateBundleLogic.setApprovalForAll(approvedAccount, false, { privateKey: assetOwnerPK });
                let failed = false;
                try {
                    const tx = yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, accountTrader, 9, '0x01', { privateKey: approvedPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'simpleTransfer, missing rights');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call safeTransferFrom with no data to random contract address as non approved account', () => __awaiter(this, void 0, void 0, function* () {
                yield energyCertificateBundleLogic.setApprovalForAll(approvedAccount, false, { privateKey: assetOwnerPK });
                let failed = false;
                try {
                    const tx = yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, energyCertificateBundleLogic.web3Contract._address, 9, '0x01', { privateKey: approvedPK });
                }
                catch (ex) {
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call safeTransferFrom with no data to correct contract address as non approved account', () => __awaiter(this, void 0, void 0, function* () {
                yield energyCertificateBundleLogic.setApprovalForAll(approvedAccount, false, { privateKey: assetOwnerPK });
                let failed = false;
                try {
                    const tx = yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, testreceiver.web3Contract._address, 9, '0x01', { privateKey: approvedPK });
                }
                catch (ex) {
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call safeTransferFrom with no data to regular address as approved account', () => __awaiter(this, void 0, void 0, function* () {
                yield energyCertificateBundleLogic.setApprovalForAll(approvedAccount, true, { privateKey: assetOwnerPK });
                let failed = false;
                try {
                    const tx = yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, accountTrader, 9, '0x01', { privateKey: approvedPK });
                }
                catch (ex) {
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call safeTransferFrom with no data to random contract address as approved account', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    const tx = yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, energyCertificateBundleLogic.web3Contract._address, 9, '0x01', { privateKey: approvedPK });
                }
                catch (ex) {
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should call safeTransferFrom with no data to correct contract address as approved account', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, testreceiver.web3Contract._address, 9, '0x01', { privateKey: approvedPK });
                if (isGanache) {
                    const allTransferEvents = yield energyCertificateBundleLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                    chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                        0: accountAssetOwner,
                        1: testreceiver.web3Contract._address,
                        2: '9',
                        _from: accountAssetOwner,
                        _to: testreceiver.web3Contract._address,
                        _tokenId: '9',
                    });
                }
                chai_1.assert.equal(yield energyCertificateBundleLogic.getBundleListLength(), 10);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountAssetOwner), 1);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountTrader), 3);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(testreceiver.web3Contract._address), 6);
            }));
            it('should return the bundle #9 again', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield energyCertificateBundleLogic.getBundle(9);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 9);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 1);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, testreceiver.web3Contract._address);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, []);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should log energy (Bundle #10)', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield assetRegistry.saveSmartMeterRead(0, 1100, 'lastSmartMeterReadFileHash', { privateKey: assetSmartmeterPK });
                const event = (yield assetRegistry.getAllLogNewMeterReadEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber }))[0];
                chai_1.assert.equal(event.event, 'LogNewMeterRead');
                chai_1.assert.deepEqual(event.returnValues, {
                    0: '0',
                    1: '1000',
                    2: '1100',
                    _assetId: '0',
                    _oldMeterRead: '1000',
                    _newMeterRead: '1100',
                });
                if (isGanache) {
                    const allTransferEvents = yield energyCertificateBundleLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                    chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                        0: '0x0000000000000000000000000000000000000000',
                        1: accountAssetOwner,
                        2: '10',
                        _from: '0x0000000000000000000000000000000000000000',
                        _to: accountAssetOwner,
                        _tokenId: '10',
                    });
                }
                chai_1.assert.equal(yield energyCertificateBundleLogic.getBundleListLength(), 11);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountAssetOwner), 2);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountTrader), 3);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(testreceiver.web3Contract._address), 6);
            }));
            it('should return the bundle #10', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield energyCertificateBundleLogic.getBundle(10);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 10);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 0);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, ['0x1000000000000000000000000000000000000005', matcherAccount]);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should approve bundle #10', () => __awaiter(this, void 0, void 0, function* () {
                yield energyCertificateBundleLogic.approve(approvedAccount, 10, { privateKey: assetOwnerPK });
                const cert = yield energyCertificateBundleLogic.getBundle(10);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 10);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 0);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, ['0x1000000000000000000000000000000000000005', matcherAccount]);
                chai_1.assert.equal(tradableEntity.approvedAddress, approvedAccount);
            }));
            it('should throw when trying to call transferFrom as non approved account', () => __awaiter(this, void 0, void 0, function* () {
                yield energyCertificateBundleLogic.setApprovalForAll(approvedAccount, false, { privateKey: assetOwnerPK });
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.transferFrom(accountAssetOwner, accountTrader, 10, { privateKey: privateKeyDeployment });
                }
                catch (ex) {
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should transferFrom as approved account', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield energyCertificateBundleLogic.transferFrom(accountAssetOwner, accountTrader, 10, { privateKey: approvedPK });
                if (isGanache) {
                    const allTransferEvents = yield energyCertificateBundleLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                    chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                        0: accountAssetOwner,
                        1: accountTrader,
                        2: '10',
                        _from: accountAssetOwner,
                        _to: accountTrader,
                        _tokenId: '10',
                    });
                }
                chai_1.assert.equal(yield energyCertificateBundleLogic.getBundleListLength(), 11);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountAssetOwner), 1);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountTrader), 4);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(testreceiver.web3Contract._address), 6);
            }));
            it('should approve bundle #10', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield energyCertificateBundleLogic.getBundle(10);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 10);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 1);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountTrader);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, []);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should log energy (Bundle #11)', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield assetRegistry.saveSmartMeterRead(0, 1200, 'lastSmartMeterReadFileHash', { privateKey: assetSmartmeterPK });
                const event = (yield assetRegistry.getAllLogNewMeterReadEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber }))[0];
                chai_1.assert.equal(event.event, 'LogNewMeterRead');
                chai_1.assert.deepEqual(event.returnValues, {
                    0: '0',
                    1: '1100',
                    2: '1200',
                    _assetId: '0',
                    _oldMeterRead: '1100',
                    _newMeterRead: '1200',
                });
                if (isGanache) {
                    const allTransferEvents = yield energyCertificateBundleLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                    chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                        0: '0x0000000000000000000000000000000000000000',
                        1: accountAssetOwner,
                        2: '11',
                        _from: '0x0000000000000000000000000000000000000000',
                        _to: accountAssetOwner,
                        _tokenId: '11',
                    });
                }
                chai_1.assert.equal(yield energyCertificateBundleLogic.getBundleListLength(), 12);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountAssetOwner), 2);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountTrader), 4);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(testreceiver.web3Contract._address), 6);
            }));
            it('should return the bundle #11', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield energyCertificateBundleLogic.getBundle(11);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 11);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 0);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, ['0x1000000000000000000000000000000000000005', matcherAccount]);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should approve bundle #11', () => __awaiter(this, void 0, void 0, function* () {
                yield energyCertificateBundleLogic.approve(approvedAccount, 11, { privateKey: assetOwnerPK });
                const cert = yield energyCertificateBundleLogic.getBundle(11);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 11);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 0);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, ['0x1000000000000000000000000000000000000005', matcherAccount]);
                chai_1.assert.equal(tradableEntity.approvedAddress, approvedAccount);
            }));
            it('should throw when trying to call safeTransferFrom with no data to an address as approved account', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, accountTrader, 11, null, { privateKey: approvedPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, '_to is not a contract');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call safeTransferFrom with no data to a random contract address as approved account', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, energyCertificateBundleLogic.web3Contract._address, 11, null, { privateKey: approvedPK });
                }
                catch (ex) {
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should call safeTransferFrom with no data to random contract address as approved account', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, testreceiver.web3Contract._address, 11, null, { privateKey: approvedPK });
                if (isGanache) {
                    const allTransferEvents = yield energyCertificateBundleLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                    chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                        0: accountAssetOwner,
                        1: testreceiver.web3Contract._address,
                        2: '11',
                        _from: accountAssetOwner,
                        _to: testreceiver.web3Contract._address,
                        _tokenId: '11',
                    });
                }
                chai_1.assert.equal(yield energyCertificateBundleLogic.getBundleListLength(), 12);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountAssetOwner), 1);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountTrader), 4);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(testreceiver.web3Contract._address), 7);
            }));
            it('should return bundle #11', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield energyCertificateBundleLogic.getBundle(11);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 11);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 1);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, testreceiver.web3Contract._address);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, []);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should log energy (Bundle #12)', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield assetRegistry.saveSmartMeterRead(0, 1300, 'lastSmartMeterReadFileHash', { privateKey: assetSmartmeterPK });
                const event = (yield assetRegistry.getAllLogNewMeterReadEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber }))[0];
                chai_1.assert.equal(event.event, 'LogNewMeterRead');
                chai_1.assert.deepEqual(event.returnValues, {
                    0: '0',
                    1: '1200',
                    2: '1300',
                    _assetId: '0',
                    _oldMeterRead: '1200',
                    _newMeterRead: '1300',
                });
                if (isGanache) {
                    const allTransferEvents = yield energyCertificateBundleLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                    chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                        0: '0x0000000000000000000000000000000000000000',
                        1: accountAssetOwner,
                        2: '12',
                        _from: '0x0000000000000000000000000000000000000000',
                        _to: accountAssetOwner,
                        _tokenId: '12',
                    });
                }
                chai_1.assert.equal(yield energyCertificateBundleLogic.getBundleListLength(), 13);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountAssetOwner), 2);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountTrader), 4);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(testreceiver.web3Contract._address), 7);
            }));
            it('should return the bundle #12', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield energyCertificateBundleLogic.getBundle(12);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 12);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 0);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, ['0x1000000000000000000000000000000000000005', matcherAccount]);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should approve bundle #12', () => __awaiter(this, void 0, void 0, function* () {
                yield energyCertificateBundleLogic.approve(approvedAccount, 12, { privateKey: assetOwnerPK });
                const cert = yield energyCertificateBundleLogic.getBundle(12);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 12);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 0);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, ['0x1000000000000000000000000000000000000005', matcherAccount]);
                chai_1.assert.equal(tradableEntity.approvedAddress, approvedAccount);
            }));
            it('should throw when trying to call safeTransferFrom with data to an address as approved account', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, accountTrader, 12, '0x01', { privateKey: approvedPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, '_to is not a contract');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call safeTransferFrom with data to a random contract address as approved account', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, energyCertificateBundleLogic.web3Contract._address, 12, '0x01', { privateKey: approvedPK });
                }
                catch (ex) {
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should call safeTransferFrom with data to random contract address as approved account', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, testreceiver.web3Contract._address, 12, '0x01', { privateKey: approvedPK });
                if (isGanache) {
                    const allTransferEvents = yield energyCertificateBundleLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                    chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                        0: accountAssetOwner,
                        1: testreceiver.web3Contract._address,
                        2: '12',
                        _from: accountAssetOwner,
                        _to: testreceiver.web3Contract._address,
                        _tokenId: '12',
                    });
                }
                chai_1.assert.equal(yield energyCertificateBundleLogic.getBundleListLength(), 13);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountAssetOwner), 1);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountTrader), 4);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(testreceiver.web3Contract._address), 8);
            }));
            it('should get bundle #12 again', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield energyCertificateBundleLogic.getBundle(12);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 12);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 1);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, testreceiver.web3Contract._address);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, []);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should log energy (Bundle #13)', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield assetRegistry.saveSmartMeterRead(0, 1400, 'lastSmartMeterReadFileHash', { privateKey: assetSmartmeterPK });
                const event = (yield assetRegistry.getAllLogNewMeterReadEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber }))[0];
                chai_1.assert.equal(event.event, 'LogNewMeterRead');
                chai_1.assert.deepEqual(event.returnValues, {
                    0: '0',
                    1: '1300',
                    2: '1400',
                    _assetId: '0',
                    _oldMeterRead: '1300',
                    _newMeterRead: '1400',
                });
                if (isGanache) {
                    const allTransferEvents = yield energyCertificateBundleLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                    chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                        0: '0x0000000000000000000000000000000000000000',
                        1: accountAssetOwner,
                        2: '13',
                        _from: '0x0000000000000000000000000000000000000000',
                        _to: accountAssetOwner,
                        _tokenId: '13',
                    });
                }
                chai_1.assert.equal(yield energyCertificateBundleLogic.getBundleListLength(), 14);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountAssetOwner), 2);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountTrader), 4);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(testreceiver.web3Contract._address), 8);
            }));
            it('should return the bundle #13', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield energyCertificateBundleLogic.getBundle(13);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 13);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 0);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, ['0x1000000000000000000000000000000000000005', matcherAccount]);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should throw when trying to call setTradableToken as admin', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.setTradableToken(13, '0x1000000000000000000000000000000000000006', { privateKey: privateKeyDeployment });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'not the enitity-owner');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call setTradableToken as trader', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.setTradableToken(13, '0x1000000000000000000000000000000000000006', { privateKey: traderPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'not the enitity-owner');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should call setTradableToken as owner', () => __awaiter(this, void 0, void 0, function* () {
                yield energyCertificateBundleLogic.setTradableToken(13, '0x1000000000000000000000000000000000000006', { privateKey: assetOwnerPK });
                const cert = yield energyCertificateBundleLogic.getBundle(13);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 13);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 0);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x1000000000000000000000000000000000000006');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, ['0x1000000000000000000000000000000000000005', matcherAccount]);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should throw when trying to call setOnChainDirectPurchasePrice as admin', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.setOnChainDirectPurchasePrice(13, 1000, { privateKey: privateKeyDeployment });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'not the enitity-owner');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call setOnChainDirectPurchasePrice as trader', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.setOnChainDirectPurchasePrice(13, 1000, { privateKey: traderPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'not the enitity-owner');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should call setOnChainDirectPurchasePrice as owner', () => __awaiter(this, void 0, void 0, function* () {
                yield energyCertificateBundleLogic.setOnChainDirectPurchasePrice(13, 1000, { privateKey: assetOwnerPK });
                const cert = yield energyCertificateBundleLogic.getBundle(13);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 13);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 0);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x1000000000000000000000000000000000000006');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 1000);
                chai_1.assert.deepEqual(tradableEntity.escrow, ['0x1000000000000000000000000000000000000005', matcherAccount]);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should reset onChainPrice and token when transfering(transferFrom) a bundle', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield energyCertificateBundleLogic.transferFrom(accountAssetOwner, accountTrader, 13, { privateKey: assetOwnerPK });
                if (isGanache) {
                    const allTransferEvents = yield energyCertificateBundleLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                    chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                        0: accountAssetOwner,
                        1: accountTrader,
                        2: '13',
                        _from: accountAssetOwner,
                        _to: accountTrader,
                        _tokenId: '13',
                    });
                }
                const cert = yield energyCertificateBundleLogic.getBundle(13);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 13);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 1);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountTrader);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, []);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(yield energyCertificateBundleLogic.getBundleListLength(), 14);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountAssetOwner), 1);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountTrader), 5);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(testreceiver.web3Contract._address), 8);
            }));
            it('should be able to transfer bundle again + auto retire', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield energyCertificateBundleLogic.transferFrom(accountTrader, accountTrader, 13, { privateKey: traderPK });
                if (isGanache) {
                    const allTransferEvents = yield energyCertificateBundleLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                    chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                        0: accountTrader,
                        1: accountTrader,
                        2: '13',
                        _from: accountTrader,
                        _to: accountTrader,
                        _tokenId: '13',
                    });
                }
                const cert = yield energyCertificateBundleLogic.getBundle(13);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isTrue(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 13);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 2);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountTrader);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, []);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(yield energyCertificateBundleLogic.getBundleListLength(), 14);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountAssetOwner), 1);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountTrader), 5);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(testreceiver.web3Contract._address), 8);
            }));
            it('should when trying to call transferFrom on retired bundle', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield energyCertificateBundleLogic.transferFrom(accountTrader, accountTrader, 13, { privateKey: traderPK });
                }
                catch (ex) {
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should log energy (Bundle #14)', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield assetRegistry.saveSmartMeterRead(0, 1500, 'lastSmartMeterReadFileHash', { privateKey: assetSmartmeterPK });
                const event = (yield assetRegistry.getAllLogNewMeterReadEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber }))[0];
                chai_1.assert.equal(event.event, 'LogNewMeterRead');
                chai_1.assert.deepEqual(event.returnValues, {
                    0: '0',
                    1: '1400',
                    2: '1500',
                    _assetId: '0',
                    _oldMeterRead: '1400',
                    _newMeterRead: '1500',
                });
                if (isGanache) {
                    const allTransferEvents = yield energyCertificateBundleLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                    chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                        0: '0x0000000000000000000000000000000000000000',
                        1: accountAssetOwner,
                        2: '14',
                        _from: '0x0000000000000000000000000000000000000000',
                        _to: accountAssetOwner,
                        _tokenId: '14',
                    });
                }
                chai_1.assert.equal(yield energyCertificateBundleLogic.getBundleListLength(), 15);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountAssetOwner), 2);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountTrader), 5);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(testreceiver.web3Contract._address), 8);
            }));
            it('should return the bundle #14', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield energyCertificateBundleLogic.getBundle(14);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 14);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 0);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, ['0x1000000000000000000000000000000000000005', matcherAccount]);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should set acceptedToken and onChainDirectPurchasePrice', () => __awaiter(this, void 0, void 0, function* () {
                yield energyCertificateBundleLogic.setTradableToken(14, '0x1000000000000000000000000000000000000006', { privateKey: assetOwnerPK });
                yield energyCertificateBundleLogic.setOnChainDirectPurchasePrice(14, 1000, { privateKey: assetOwnerPK });
                const cert = yield energyCertificateBundleLogic.getBundle(14);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 14);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 0);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x1000000000000000000000000000000000000006');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 1000);
                chai_1.assert.deepEqual(tradableEntity.escrow, ['0x1000000000000000000000000000000000000005', matcherAccount]);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should reset onChainPrice and token when transfering(safeTransferFrom without data) a bundle', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, testreceiver.web3Contract._address, 14, null, { privateKey: assetOwnerPK });
                if (isGanache) {
                    const allTransferEvents = yield energyCertificateBundleLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                    chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                        0: accountAssetOwner,
                        1: testreceiver.web3Contract._address,
                        2: '14',
                        _from: accountAssetOwner,
                        _to: testreceiver.web3Contract._address,
                        _tokenId: '14',
                    });
                }
                const cert = yield energyCertificateBundleLogic.getBundle(14);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 14);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 1);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, testreceiver.web3Contract._address);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, []);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(yield energyCertificateBundleLogic.getBundleListLength(), 15);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountAssetOwner), 1);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountTrader), 5);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(testreceiver.web3Contract._address), 9);
            }));
            it('should be able to transfer bundle again + auto retire #2', () => __awaiter(this, void 0, void 0, function* () {
                yield userLogic.setUser(testreceiver.web3Contract._address, 'TestReceiver', { privateKey: privateKeyDeployment });
                yield userLogic.setRoles(testreceiver.web3Contract._address, 16, { privateKey: privateKeyDeployment });
                const tx = yield testreceiver.safeTransferFrom(testreceiver.web3Contract._address, testreceiver.web3Contract._address, 14, null, { privateKey: privateKeyDeployment });
                if (isGanache) {
                    const allTransferEvents = yield energyCertificateBundleLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                    chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                        0: testreceiver.web3Contract._address,
                        1: testreceiver.web3Contract._address,
                        2: '14',
                        _from: testreceiver.web3Contract._address,
                        _to: testreceiver.web3Contract._address,
                        _tokenId: '14',
                    });
                }
                const cert = yield energyCertificateBundleLogic.getBundle(14);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isTrue(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 14);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 2);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, testreceiver.web3Contract._address);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, []);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(yield energyCertificateBundleLogic.getBundleListLength(), 15);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountAssetOwner), 1);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountTrader), 5);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(testreceiver.web3Contract._address), 9);
            }));
            it('should when trying to call safeTransferFrom on retired bundle', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield testreceiver.safeTransferFrom(testreceiver.web3Contract._address, testreceiver.web3Contract._address, 14, null, { privateKey: privateKeyDeployment });
                }
                catch (ex) {
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should log energy (Bundle #15)', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield assetRegistry.saveSmartMeterRead(0, 1600, 'lastSmartMeterReadFileHash', { privateKey: assetSmartmeterPK });
                const event = (yield assetRegistry.getAllLogNewMeterReadEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber }))[0];
                chai_1.assert.equal(event.event, 'LogNewMeterRead');
                chai_1.assert.deepEqual(event.returnValues, {
                    0: '0',
                    1: '1500',
                    2: '1600',
                    _assetId: '0',
                    _oldMeterRead: '1500',
                    _newMeterRead: '1600',
                });
                if (isGanache) {
                    const allTransferEvents = yield energyCertificateBundleLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                    chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                        0: '0x0000000000000000000000000000000000000000',
                        1: accountAssetOwner,
                        2: '15',
                        _from: '0x0000000000000000000000000000000000000000',
                        _to: accountAssetOwner,
                        _tokenId: '15',
                    });
                }
                chai_1.assert.equal(yield energyCertificateBundleLogic.getBundleListLength(), 16);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountAssetOwner), 2);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountTrader), 5);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(testreceiver.web3Contract._address), 9);
            }));
            it('should return the bundle #15', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield energyCertificateBundleLogic.getBundle(15);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 15);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 0);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, ['0x1000000000000000000000000000000000000005', matcherAccount]);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should set acceptedToken and onChainDirectPurchasePrice', () => __awaiter(this, void 0, void 0, function* () {
                yield energyCertificateBundleLogic.setTradableToken(15, '0x1000000000000000000000000000000000000006', { privateKey: assetOwnerPK });
                yield energyCertificateBundleLogic.setOnChainDirectPurchasePrice(15, 1000, { privateKey: assetOwnerPK });
                const cert = yield energyCertificateBundleLogic.getBundle(15);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 15);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 0);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x1000000000000000000000000000000000000006');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 1000);
                chai_1.assert.deepEqual(tradableEntity.escrow, ['0x1000000000000000000000000000000000000005', matcherAccount]);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should reset onChainPrice and token when transfering(safeTransferFrom with data) a bundle', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield energyCertificateBundleLogic.safeTransferFrom(accountAssetOwner, testreceiver.web3Contract._address, 15, '0x01', { privateKey: assetOwnerPK });
                if (isGanache) {
                    const allTransferEvents = yield energyCertificateBundleLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                    chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                        0: accountAssetOwner,
                        1: testreceiver.web3Contract._address,
                        2: '15',
                        _from: accountAssetOwner,
                        _to: testreceiver.web3Contract._address,
                        _tokenId: '15',
                    });
                }
                const cert = yield energyCertificateBundleLogic.getBundle(15);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 15);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 1);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, testreceiver.web3Contract._address);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, []);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(yield energyCertificateBundleLogic.getBundleListLength(), 16);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountAssetOwner), 1);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountTrader), 5);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(testreceiver.web3Contract._address), 10);
            }));
            it('should be able to transfer bundle again + auto retire #3', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield testreceiver.safeTransferFrom(testreceiver.web3Contract._address, testreceiver.web3Contract._address, 15, '0x01', { privateKey: privateKeyDeployment });
                if (isGanache) {
                    const allTransferEvents = yield energyCertificateBundleLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents.length, 1);
                    chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                    chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                        0: testreceiver.web3Contract._address,
                        1: testreceiver.web3Contract._address,
                        2: '15',
                        _from: testreceiver.web3Contract._address,
                        _to: testreceiver.web3Contract._address,
                        _tokenId: '15',
                    });
                }
                const cert = yield energyCertificateBundleLogic.getBundle(15);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isTrue(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 15);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 2);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, testreceiver.web3Contract._address);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, []);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(yield energyCertificateBundleLogic.getBundleListLength(), 16);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountAssetOwner), 1);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(accountTrader), 5);
                chai_1.assert.equal(yield energyCertificateBundleLogic.balanceOf(testreceiver.web3Contract._address), 10);
            }));
            it('should when trying to call safeTransferFrom on retired bundle', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield testreceiver.safeTransferFrom(testreceiver.web3Contract._address, testreceiver.web3Contract._address, 15, '0x01', { privateKey: privateKeyDeployment });
                }
                catch (ex) {
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
        });
    });
});
//# sourceMappingURL=EnergyCertificateBundleLogic.js.map