"use strict";
// Copyright 2018 Energy Web Foundation
// This file is part of the Origin Application brought to you by the Energy Web Foundation,
// a global non-profit organization focused on accelerating blockchain technology across the energy sector,
// incorporated in Zug, Switzerland.
//
// The Origin Application is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// This is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY and without an implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details, at <http://www.gnu.org/licenses/>.
//
// @authors: slock.it GmbH; Martin Kuechler, martin.kuchler@slock.it; Heiko Burkhardt, heiko.burkhardt@slock.it;
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const fs = __importStar(require("fs"));
require("mocha");
const ew_user_registry_contracts_1 = require("ew-user-registry-contracts");
const ew_asset_registry_contracts_1 = require("ew-asset-registry-contracts");
const migrateContracts_1 = require("../utils/migrateContracts");
const OriginContractLookup_1 = require("../wrappedContracts/OriginContractLookup");
const CertificateDB_1 = require("../wrappedContracts/CertificateDB");
const CertificateLogic_1 = require("../wrappedContracts/CertificateLogic");
const TestReceiver_1 = require("../wrappedContracts/TestReceiver");
const Erc20TestToken_1 = require("../wrappedContracts/Erc20TestToken");
const web3_1 = __importDefault(require("web3"));
const Erc20TestToken_json_1 = __importDefault(require("../../contract-build/Erc20TestToken.json"));
const TestReceiver_json_1 = __importDefault(require("../../contract-build/TestReceiver.json"));
const ew_utils_deployment_1 = require("ew-utils-deployment");
const __1 = require("..");
describe.skip('CertificateLogic', () => {
    let assetRegistryContract;
    let originRegistryContract;
    let certificateLogic;
    let certificateDB;
    // let isGanache: boolean;
    let userRegistryContract;
    let assetRegistry;
    let userLogic;
    let testreceiver;
    let erc20Test;
    let erc721testReceiverAddress;
    const configFile = JSON.parse(fs.readFileSync(process.cwd() + '/connection-config.json', 'utf8'));
    const web3 = new web3_1.default(configFile.develop.web3);
    const privateKeyDeployment = configFile.develop.deployKey.startsWith('0x') ?
        configFile.develop.deployKey : '0x' + configFile.develop.deployKey;
    const accountDeployment = web3.eth.accounts.privateKeyToAccount(privateKeyDeployment).address;
    const assetOwnerPK = '0xc118b0425221384fe0cbbd093b2a81b1b65d0330810e0792c7059e518cea5383';
    const accountAssetOwner = web3.eth.accounts.privateKeyToAccount(assetOwnerPK).address;
    const traderPK = '0x2dc5120c26df339dbd9861a0f39a79d87e0638d30fdedc938861beac77bbd3f5';
    const accountTrader = web3.eth.accounts.privateKeyToAccount(traderPK).address;
    const assetSmartmeterPK = '0x2dc5120c26df339dbd9861a0f39a79d87e0638d30fdedc938861beac77bbd3f5';
    const assetSmartmeter = web3.eth.accounts.privateKeyToAccount(assetSmartmeterPK).address;
    const matcherPK = '0xd9d5e7a2ebebbad1eb22a63baa739a6c6a6f15d07fcc990ea4dea5c64022a87a';
    const matcherAccount = web3.eth.accounts.privateKeyToAccount(matcherPK).address;
    const approvedPK = '0x7da67da863672d4cc2984e93ce28d98b0d782d8caa43cd1c977b919c0209541b';
    const approvedAccount = web3.eth.accounts.privateKeyToAccount(approvedPK).address;
    describe('init checks', () => {
        it('should deploy the contracts', () => __awaiter(this, void 0, void 0, function* () {
            // isGanache = (await getClientVersion(web3)).includes('EthereumJS');
            const userContracts = yield ew_user_registry_contracts_1.migrateUserRegistryContracts(web3, privateKeyDeployment);
            userLogic = new ew_user_registry_contracts_1.UserLogic(web3, userContracts.UserLogic);
            yield userLogic.setUser(accountDeployment, 'admin', { privateKey: privateKeyDeployment });
            yield userLogic.setRoles(accountDeployment, 3, { privateKey: privateKeyDeployment });
            const userContractLookupAddr = userContracts.UserContractLookup;
            userRegistryContract = new ew_user_registry_contracts_1.UserContractLookup(web3, userContractLookupAddr);
            const assetContracts = yield ew_asset_registry_contracts_1.migrateAssetRegistryContracts(web3, userContractLookupAddr, privateKeyDeployment);
            const assetRegistryLookupAddr = assetContracts.AssetContractLookup;
            const assetProducingAddr = assetContracts.AssetProducingRegistryLogic;
            const originContracts = yield migrateContracts_1.migrateCertificateRegistryContracts(web3, assetRegistryLookupAddr, privateKeyDeployment);
            assetRegistryContract = new ew_asset_registry_contracts_1.AssetContractLookup(web3, assetRegistryLookupAddr);
            assetRegistry = new ew_asset_registry_contracts_1.AssetProducingRegistryLogic(web3, assetProducingAddr);
            // originRegistryContract = new OriginContractLookup((web3 as any));
            // certificateLogic = new CertificateLogic((web3 as any));
            // certificateDB = new CertificateDB((web3 as any));
            // assetRegistry = new AssetProducingRegistryLogic((web3 as any), assetProducingAddr);
            Object.keys(originContracts).forEach((key) => __awaiter(this, void 0, void 0, function* () {
                let tempBytecode;
                if (key.includes('OriginContractLookup')) {
                    originRegistryContract = new OriginContractLookup_1.OriginContractLookup(web3, originContracts[key]);
                    tempBytecode = '0x' + __1.OriginContractLookupJSON.deployedBytecode;
                }
                if (key.includes('CertificateLogic')) {
                    certificateLogic = new CertificateLogic_1.CertificateLogic(web3, originContracts[key]);
                    tempBytecode = '0x' + __1.CertificateLogicJSON.deployedBytecode;
                }
                if (key.includes('CertificateDB')) {
                    certificateDB = new CertificateDB_1.CertificateDB(web3, originContracts[key]);
                    tempBytecode = '0x' + __1.CertificateDBJSON.deployedBytecode;
                }
                const deployedBytecode = yield web3.eth.getCode(originContracts[key]);
                chai_1.assert.isTrue(deployedBytecode.length > 0);
                chai_1.assert.equal(deployedBytecode, tempBytecode);
            }));
        }));
        it('should deploy a testtoken contracts', () => __awaiter(this, void 0, void 0, function* () {
            erc721testReceiverAddress = (yield ew_utils_deployment_1.deploy(web3, TestReceiver_json_1.default.bytecode + web3.eth.abi.encodeParameter('address', certificateLogic.web3Contract.options.address).substr(2), {
                privateKey: privateKeyDeployment,
            })).contractAddress;
            const erc20testContractAddress = (yield ew_utils_deployment_1.deploy(web3, Erc20TestToken_json_1.default.bytecode + web3.eth.abi.encodeParameter('address', accountTrader).substr(2), {
                privateKey: privateKeyDeployment,
            })).contractAddress;
            testreceiver = new TestReceiver_1.TestReceiver(web3, erc721testReceiverAddress);
            erc20Test = new Erc20TestToken_1.Erc20TestToken(web3, erc20testContractAddress);
        }));
        it('should have the right owner', () => __awaiter(this, void 0, void 0, function* () {
            chai_1.assert.equal(yield certificateLogic.owner(), originRegistryContract.web3Contract._address);
        }));
        it('should have the lookup-contracts', () => __awaiter(this, void 0, void 0, function* () {
            chai_1.assert.equal(yield certificateLogic.assetContractLookup(), assetRegistryContract.web3Contract._address);
            chai_1.assert.equal(yield certificateLogic.userContractLookup(), userRegistryContract.web3Contract._address);
        }));
        it('should the correct DB', () => __awaiter(this, void 0, void 0, function* () {
            chai_1.assert.equal(yield certificateLogic.db(), certificateDB.web3Contract._address);
        }));
        it('should have balances of 0', () => __awaiter(this, void 0, void 0, function* () {
            chai_1.assert.equal(yield certificateLogic.balanceOf(accountDeployment), 0);
            chai_1.assert.equal(yield certificateLogic.balanceOf(accountAssetOwner), 0);
            chai_1.assert.equal(yield certificateLogic.balanceOf(accountTrader), 0);
        }));
        it('should throw for balance of address 0x0', () => __awaiter(this, void 0, void 0, function* () {
            let failed = false;
            try {
                yield certificateLogic.balanceOf('0x0000000000000000000000000000000000000000');
            }
            catch (ex) {
                failed = true;
            }
            chai_1.assert.isTrue(failed);
        }));
        it('should throw when trying to access a non existing certificate', () => __awaiter(this, void 0, void 0, function* () {
            let failed = false;
            try {
                yield certificateLogic.ownerOf(0);
            }
            catch (ex) {
                failed = true;
            }
            chai_1.assert.isTrue(failed);
        }));
        it('should throw when trying to call safeTransferFrom a non existing certificate', () => __awaiter(this, void 0, void 0, function* () {
            let failed = false;
            try {
                yield certificateLogic.safeTransferFrom(accountDeployment, accountTrader, 0, '0x00', { privateKey: privateKeyDeployment });
            }
            catch (ex) {
                failed = true;
            }
            chai_1.assert.isTrue(failed);
        }));
        it('should throw when trying to call safeTransferFrom a non existing certificate', () => __awaiter(this, void 0, void 0, function* () {
            let failed = false;
            try {
                yield certificateLogic.safeTransferFrom(accountDeployment, accountTrader, 0, { privateKey: privateKeyDeployment });
            }
            catch (ex) {
                failed = true;
            }
            chai_1.assert.isTrue(failed);
        }));
        it('should throw when trying to call transferFrom a non existing certificate', () => __awaiter(this, void 0, void 0, function* () {
            let failed = false;
            try {
                yield certificateLogic.transferFrom(accountDeployment, accountTrader, 0, { privateKey: privateKeyDeployment });
            }
            catch (ex) {
                failed = true;
            }
            chai_1.assert.isTrue(failed);
        }));
        it('should throw when trying to call approve a non existing certificate', () => __awaiter(this, void 0, void 0, function* () {
            let failed = false;
            try {
                yield certificateLogic.approve(accountTrader, 0, { privateKey: privateKeyDeployment });
            }
            catch (ex) {
                failed = true;
            }
            chai_1.assert.isTrue(failed);
        }));
        it('should set right roles to users', () => __awaiter(this, void 0, void 0, function* () {
            yield userLogic.setUser(accountTrader, 'trader', { privateKey: privateKeyDeployment });
            yield userLogic.setUser(accountAssetOwner, 'assetOwner', { privateKey: privateKeyDeployment });
            yield userLogic.setUser(testreceiver.web3Contract._address, 'testreceiver', { privateKey: privateKeyDeployment });
            yield userLogic.setRoles(testreceiver.web3Contract._address, 16, { privateKey: privateKeyDeployment });
            yield userLogic.setRoles(accountTrader, 16, { privateKey: privateKeyDeployment });
            yield userLogic.setRoles(accountAssetOwner, 24, { privateKey: privateKeyDeployment });
        }));
        it('should onboard an asset', () => __awaiter(this, void 0, void 0, function* () {
            yield assetRegistry.createAsset(assetSmartmeter, accountAssetOwner, true, ['0x1000000000000000000000000000000000000005'], 'propertiesDocumentHash', 'url', 2, { privateKey: privateKeyDeployment });
        }));
        it('should set MarketLogicAddress', () => __awaiter(this, void 0, void 0, function* () {
            yield assetRegistry.setMarketLookupContract(0, originRegistryContract.web3Contract._address, { privateKey: assetOwnerPK });
            chai_1.assert.equal(yield assetRegistry.getMarketLookupContract(0), originRegistryContract.web3Contract._address);
        }));
        it('should return right interface', () => __awaiter(this, void 0, void 0, function* () {
            chai_1.assert.isTrue(yield certificateLogic.supportsInterface('0x80ac58cd'));
            chai_1.assert.isFalse(yield certificateLogic.supportsInterface('0x80ac58c1'));
        }));
        describe('transferFrom', () => {
            it('should have 0 certificates', () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.equal(yield certificateLogic.getCertificateListLength(), 0);
            }));
            it('should log energy', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield assetRegistry.saveSmartMeterRead(0, 100, 'lastSmartMeterReadFileHash', { privateKey: assetSmartmeterPK });
                const event = (yield assetRegistry.getAllLogNewMeterReadEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber }))[0];
                chai_1.assert.equal(event.event, 'LogNewMeterRead');
                chai_1.assert.deepEqual(event.returnValues, {
                    0: '0',
                    1: '0',
                    2: '100',
                    _assetId: '0',
                    _oldMeterRead: '0',
                    _newMeterRead: '100',
                });
                //  if (isGanache) {
                const allTransferEvents = yield certificateLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                    0: '0x0000000000000000000000000000000000000000',
                    1: accountAssetOwner,
                    2: '0',
                    _from: '0x0000000000000000000000000000000000000000',
                    _to: accountAssetOwner,
                    _tokenId: '0',
                });
                //    }
            }));
            it('should have 1 certificate', () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.equal(yield certificateLogic.getCertificateListLength(), 1);
            }));
            it('should return the certificate', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield certificateLogic.getCertificate(0);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 0);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 0);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, ['0x1000000000000000000000000000000000000005']);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should hava balance of 1 for assetOwner address', () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountAssetOwner), 1);
            }));
            it('should return the correct owner', () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.equal(yield certificateLogic.ownerOf(0), accountAssetOwner);
            }));
            it('should return correct approvedFor', () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.equal(yield certificateLogic.getApproved(0), '0x0000000000000000000000000000000000000000');
            }));
            it('should return correct isApprovedForAll', () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.isFalse(yield certificateLogic.isApprovedForAll(accountAssetOwner, accountDeployment));
                chai_1.assert.isFalse(yield certificateLogic.isApprovedForAll(accountAssetOwner, accountTrader));
            }));
            it('should split the certificate', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield certificateLogic.splitCertificate(0, 40, { privateKey: assetOwnerPK });
                chai_1.assert.equal(yield certificateLogic.getCertificateListLength(), 3);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountAssetOwner), 3);
                // Parent
                const certParent = yield certificateLogic.getCertificate(0);
                const certificateSpecificParent = certParent.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecificParent.retired);
                chai_1.assert.equal(certificateSpecificParent.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecificParent.parentId, 0);
                chai_1.assert.equal(certificateSpecificParent.children.length, 2);
                chai_1.assert.equal(certificateSpecificParent.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecificParent.ownerChangeCounter, 0);
                const tradableEntityParent = certParent.tradableEntity;
                chai_1.assert.equal(tradableEntityParent.assetId, 0);
                chai_1.assert.equal(tradableEntityParent.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntityParent.powerInW, 100);
                chai_1.assert.equal(tradableEntityParent.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntityParent.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntityParent.escrow, ['0x1000000000000000000000000000000000000005']);
                chai_1.assert.equal(tradableEntityParent.approvedAddress, '0x0000000000000000000000000000000000000000');
                // child 1
                const certChildOne = yield certificateLogic.getCertificate(1);
                const certificateSpecificChildOne = certChildOne.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecificChildOne.retired);
                chai_1.assert.equal(certificateSpecificChildOne.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecificChildOne.parentId, 0);
                chai_1.assert.equal(certificateSpecificChildOne.children.length, 0);
                chai_1.assert.equal(certificateSpecificChildOne.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecificChildOne.ownerChangeCounter, 0);
                const tradableEntityChildOne = certChildOne.tradableEntity;
                chai_1.assert.equal(tradableEntityChildOne.assetId, 0);
                chai_1.assert.equal(tradableEntityChildOne.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntityChildOne.powerInW, 40);
                chai_1.assert.equal(tradableEntityChildOne.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntityChildOne.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntityChildOne.escrow, ['0x1000000000000000000000000000000000000005']);
                chai_1.assert.equal(tradableEntityChildOne.approvedAddress, '0x0000000000000000000000000000000000000000');
                // child 2
                const certChildTwo = yield certificateLogic.getCertificate(2);
                const certificateSpecificChildTwo = certChildTwo.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecificChildTwo.retired);
                chai_1.assert.equal(certificateSpecificChildTwo.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecificChildTwo.parentId, 0);
                chai_1.assert.equal(certificateSpecificChildTwo.children.length, 0);
                chai_1.assert.equal(certificateSpecificChildTwo.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecificChildTwo.ownerChangeCounter, 0);
                const tradableEntityChildTwo = certChildTwo.tradableEntity;
                chai_1.assert.equal(tradableEntityChildTwo.assetId, 0);
                chai_1.assert.equal(tradableEntityChildTwo.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntityChildTwo.powerInW, 60);
                chai_1.assert.equal(tradableEntityChildTwo.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntityChildTwo.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntityChildTwo.escrow, ['0x1000000000000000000000000000000000000005']);
                chai_1.assert.equal(tradableEntityChildTwo.approvedAddress, '0x0000000000000000000000000000000000000000');
                // if (isGanache) {
                const allTransferEvents = yield certificateLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allTransferEvents.length, 2);
                chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                    0: '0x0000000000000000000000000000000000000000',
                    1: accountAssetOwner,
                    2: '1',
                    _from: '0x0000000000000000000000000000000000000000',
                    _to: accountAssetOwner,
                    _tokenId: '1',
                });
                chai_1.assert.equal(allTransferEvents[1].event, 'Transfer');
                chai_1.assert.deepEqual(allTransferEvents[1].returnValues, {
                    0: '0x0000000000000000000000000000000000000000',
                    1: accountAssetOwner,
                    2: '2',
                    _from: '0x0000000000000000000000000000000000000000',
                    _to: accountAssetOwner,
                    _tokenId: '2',
                });
                const certSplittedEvent = yield certificateLogic.getAllLogCertificateSplitEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(certSplittedEvent.length, 1);
                chai_1.assert.equal(certSplittedEvent[0].event, 'LogCertificateSplit');
                chai_1.assert.deepEqual(certSplittedEvent[0].returnValues, {
                    0: '0',
                    1: '1',
                    2: '2',
                    _certificateId: '0',
                    _childOne: '1',
                    _childTwo: '2',
                });
                //    }
            }));
            it('should throw when trying to call transferFrom as an admin that does not own that', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.transferFrom(accountAssetOwner, accountTrader, 1, { privateKey: privateKeyDeployment });
                }
                catch (ex) {
                    chai_1.assert.include(ex.message, 'user does not have the required role');
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call transferFrom as an trader that does not own that', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.transferFrom(accountAssetOwner, accountTrader, 1, { privateKey: traderPK });
                }
                catch (ex) {
                    chai_1.assert.include(ex.message, 'simpleTransfer, missing rights');
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call transferFrom using wrong _from', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.transferFrom(accountDeployment, accountTrader, 1, { privateKey: assetOwnerPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'not the owner of the entity');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call transferFrom as an admin on a split certificate', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.transferFrom(accountAssetOwner, accountTrader, 0, { privateKey: privateKeyDeployment });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'user does not have the required role');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call transferFrom as an trader on a split certificate', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.transferFrom(accountAssetOwner, accountTrader, 0, { privateKey: traderPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'simpleTransfer, missing rights');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call transferFrom on a split certificate', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.transferFrom(accountAssetOwner, accountTrader, 0, { privateKey: assetOwnerPK });
                }
                catch (ex) {
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should be able to do transferFrom', () => __awaiter(this, void 0, void 0, function* () {
                //       await certificateLogic.approve(accountAssetOwner, 1, { privateKey: assetOwnerPK });
                const tx = yield certificateLogic.transferFrom(accountAssetOwner, accountTrader, 1, { privateKey: assetOwnerPK });
                chai_1.assert.equal(yield certificateLogic.getCertificateListLength(), 3);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountAssetOwner), 2);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountTrader), 1);
                //   if (isGanache) {
                const allEvents = yield certificateLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allEvents.length, 1);
                chai_1.assert.equal(allEvents[0].event, 'Transfer');
                chai_1.assert.deepEqual(allEvents[0].returnValues, {
                    0: accountAssetOwner,
                    1: accountTrader,
                    2: '1',
                    _from: accountAssetOwner,
                    _to: accountTrader,
                    _tokenId: '1',
                });
                //  }
            }));
            it('should return the certificate', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield certificateLogic.getCertificate(1);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 0);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 1);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountTrader);
                chai_1.assert.equal(tradableEntity.powerInW, 40);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, []);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should be able to transfer the certiificate a 2nd time ', () => __awaiter(this, void 0, void 0, function* () {
                //       await certificateLogic.approve(accountAssetOwner, 1, { privateKey: assetOwnerPK });
                const tx = yield certificateLogic.transferFrom(accountTrader, accountTrader, 1, { privateKey: traderPK });
                chai_1.assert.equal(yield certificateLogic.getCertificateListLength(), 3);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountAssetOwner), 2);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountTrader), 1);
                // if (isGanache) {
                const allEvents = yield certificateLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allEvents.length, 1);
                chai_1.assert.equal(allEvents[0].event, 'Transfer');
                chai_1.assert.deepEqual(allEvents[0].returnValues, {
                    0: accountTrader,
                    1: accountTrader,
                    2: '1',
                    _from: accountTrader,
                    _to: accountTrader,
                    _tokenId: '1',
                });
                //  }
                const retireEvent = yield certificateLogic.getAllLogCertificateRetiredEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(retireEvent.length, 1);
                chai_1.assert.equal(retireEvent[0].event, 'LogCertificateRetired');
                chai_1.assert.deepEqual(retireEvent[0].returnValues, {
                    0: '1', 1: true, _certificateId: '1', _retire: true,
                });
            }));
            it('should return the certificate (should have retired it)', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield certificateLogic.getCertificate(1);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isTrue(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 0);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 2);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountTrader);
                chai_1.assert.equal(tradableEntity.powerInW, 40);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, []);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should throw when trying to call transferFrom on a retired certificate', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.transferFrom(accountTrader, accountTrader, 1, { privateKey: traderPK });
                }
                catch (ex) {
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call split on a retired certificate', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.splitCertificate(1, 20, { privateKey: traderPK });
                }
                catch (ex) {
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call transferFrom on a splitted certificate', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.transferFrom(accountTrader, accountTrader, 0, { privateKey: assetOwnerPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'not the owner of the entity');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call split on a splitted certificate', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.splitCertificate(0, 20, { privateKey: assetOwnerPK });
                }
                catch (ex) {
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
        });
        describe('saveTransferFrom without data', () => {
            it('should log energy again (certificate #3)', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield assetRegistry.saveSmartMeterRead(0, 200, 'lastSmartMeterReadFileHash', { privateKey: assetSmartmeterPK });
                const event = (yield assetRegistry.getAllLogNewMeterReadEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber }))[0];
                chai_1.assert.equal(event.event, 'LogNewMeterRead');
                chai_1.assert.deepEqual(event.returnValues, {
                    0: '0',
                    1: '100',
                    2: '200',
                    _assetId: '0',
                    _oldMeterRead: '100',
                    _newMeterRead: '200',
                });
                //  if (isGanache) {
                const allTransferEvents = yield certificateLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                    0: '0x0000000000000000000000000000000000000000',
                    1: accountAssetOwner,
                    2: '3',
                    _from: '0x0000000000000000000000000000000000000000',
                    _to: accountAssetOwner,
                    _tokenId: '3',
                });
                //   }
                chai_1.assert.equal(yield certificateLogic.getCertificateListLength(), 4);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountAssetOwner), 3);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountTrader), 1);
                chai_1.assert.equal(yield certificateLogic.balanceOf(testreceiver.web3Contract._address), 0);
            }));
            it('should return the certificate #3', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield certificateLogic.getCertificate(3);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 3);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 0);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, ['0x1000000000000000000000000000000000000005']);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should throw when trying to call safetransferFrom as non owner(admin) and wrong receiver', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.safeTransferFrom(accountAssetOwner, accountTrader, 3, '', { privateKey: privateKeyDeployment });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'user does not have the required role');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call safetransferFrom as non owner (trader) and wrong receiver', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.safeTransferFrom(accountAssetOwner, accountTrader, 3, '', { privateKey: traderPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'simpleTransfer, missing rights');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call safetransferFrom as assetManager and wrong receiver ', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.safeTransferFrom(accountAssetOwner, accountTrader, 3, '', { privateKey: privateKeyDeployment });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'user does not have the required role');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call safetransferFrom as non owner(admin) and correct receiver', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.safeTransferFrom(accountAssetOwner, testreceiver.web3Contract._address, 3, '', { privateKey: privateKeyDeployment });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'user does not have the required role');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call safetransferFrom as non owner (trader) and correct receiver', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.safeTransferFrom(accountAssetOwner, testreceiver.web3Contract._address, 3, '', { privateKey: traderPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'simpleTransfer, missing rights');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call safetransferFrom as owner and regular account', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.safeTransferFrom(accountAssetOwner, accountTrader, 3, '', { privateKey: assetOwnerPK });
                }
                catch (ex) {
                    failed = true;
                    //   assert.include(ex.message, "simpleTransfer, missing rights")
                    console.log(ex.message);
                    chai_1.assert.include(ex.message, '_to is not a contract');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call safetransferFrom as owner random contract', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.safeTransferFrom(accountAssetOwner, certificateLogic.web3Contract._address, 3, '', { privateKey: assetOwnerPK });
                }
                catch (ex) {
                    failed = true;
                    //   assert.include(ex.message, "simpleTransfer, missing rights")
                    //   console.log(ex.message)
                    //   assert.include(ex.message, "_to did not respond correctly")
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should call safetransferFrom as assetManager and correct receiver ', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield certificateLogic.safeTransferFrom(accountAssetOwner, testreceiver.web3Contract.options.address, 3, '', { privateKey: assetOwnerPK });
                //    if (isGanache) {
                const allTransferEvents = yield certificateLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                    0: accountAssetOwner,
                    1: testreceiver.web3Contract._address,
                    2: '3',
                    _from: accountAssetOwner,
                    _to: testreceiver.web3Contract._address,
                    _tokenId: '3',
                });
                //   }
                chai_1.assert.equal(yield certificateLogic.getCertificateListLength(), 4);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountAssetOwner), 2);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountTrader), 1);
                chai_1.assert.equal(yield certificateLogic.balanceOf(testreceiver.web3Contract._address), 1);
            }));
            it('should return the certificate #3 again', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield certificateLogic.getCertificate(3);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 3);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 1);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, testreceiver.web3Contract._address);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, []);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should be able to transfer token again', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield testreceiver.safeTransferFrom(testreceiver.web3Contract._address, testreceiver.web3Contract._address, 3, '', {
                    privateKey: traderPK,
                });
                const cert = yield certificateLogic.getCertificate(3);
                //  if (isGanache) {
                const allTransferEvents = yield certificateLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                    0: testreceiver.web3Contract._address,
                    1: testreceiver.web3Contract._address,
                    2: '3',
                    _from: testreceiver.web3Contract._address,
                    _to: testreceiver.web3Contract._address,
                    _tokenId: '3',
                });
                //    }
                const retireEvent = yield certificateLogic.getAllLogCertificateRetiredEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(retireEvent.length, 1);
                chai_1.assert.equal(retireEvent[0].event, 'LogCertificateRetired');
                chai_1.assert.deepEqual(retireEvent[0].returnValues, {
                    0: '3', 1: true, _certificateId: '3', _retire: true,
                });
                chai_1.assert.equal(yield certificateLogic.getCertificateListLength(), 4);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountAssetOwner), 2);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountTrader), 1);
                chai_1.assert.equal(yield certificateLogic.balanceOf(testreceiver.web3Contract._address), 1);
            }));
            it('should return the certificate #3 again', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield certificateLogic.getCertificate(3);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isTrue(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 3);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 2);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, testreceiver.web3Contract._address);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, []);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
        });
        describe('saveTransferFrom with data', () => {
            it('should log energy again (certificate #4)', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield assetRegistry.saveSmartMeterRead(0, 300, 'lastSmartMeterReadFileHash', { privateKey: assetSmartmeterPK });
                const event = (yield assetRegistry.getAllLogNewMeterReadEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber }))[0];
                chai_1.assert.equal(event.event, 'LogNewMeterRead');
                chai_1.assert.deepEqual(event.returnValues, {
                    0: '0',
                    1: '200',
                    2: '300',
                    _assetId: '0',
                    _oldMeterRead: '200',
                    _newMeterRead: '300',
                });
                //    if (isGanache) {
                const allTransferEvents = yield certificateLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                    0: '0x0000000000000000000000000000000000000000',
                    1: accountAssetOwner,
                    2: '4',
                    _from: '0x0000000000000000000000000000000000000000',
                    _to: accountAssetOwner,
                    _tokenId: '4',
                });
                //    }
                chai_1.assert.equal(yield certificateLogic.getCertificateListLength(), 5);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountAssetOwner), 3);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountTrader), 1);
                chai_1.assert.equal(yield certificateLogic.balanceOf(testreceiver.web3Contract._address), 1);
            }));
            it('should return the certificate #4', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield certificateLogic.getCertificate(4);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 4);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 0);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, ['0x1000000000000000000000000000000000000005']);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should throw when trying to call safetransferFrom as non owner(admin) and wrong receiver', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.safeTransferFrom(accountAssetOwner, accountTrader, 4, '0x01', { privateKey: privateKeyDeployment });
                }
                catch (ex) {
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call safetransferFrom as non owner (trader) and wrong receiver', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.safeTransferFrom(accountAssetOwner, accountTrader, 4, '0x01', { privateKey: traderPK });
                }
                catch (ex) {
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call safetransferFrom as assetManager and wrong receiver ', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.safeTransferFrom(accountAssetOwner, accountTrader, 4, '0x01', { privateKey: privateKeyDeployment });
                }
                catch (ex) {
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call safetransferFrom as non owner(admin) and correct receiver', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.safeTransferFrom(accountAssetOwner, testreceiver.web3Contract._address, 4, '0x01', { privateKey: privateKeyDeployment });
                }
                catch (ex) {
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to call safetransferFrom as non owner (trader) and correct receiver', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.safeTransferFrom(accountAssetOwner, testreceiver.web3Contract._address, 4, '0x01', { privateKey: traderPK });
                }
                catch (ex) {
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should call safetransferFrom as assetManager and correct receiver ', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield certificateLogic.safeTransferFrom(accountAssetOwner, testreceiver.web3Contract._address, 4, '0x01', { privateKey: assetOwnerPK });
                //  if (isGanache) {
                const allTransferEvents = yield certificateLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                    0: accountAssetOwner,
                    1: testreceiver.web3Contract._address,
                    2: '4',
                    _from: accountAssetOwner,
                    _to: testreceiver.web3Contract._address,
                    _tokenId: '4',
                });
                //   }
                chai_1.assert.equal(yield certificateLogic.getCertificateListLength(), 5);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountAssetOwner), 2);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountTrader), 1);
                chai_1.assert.equal(yield certificateLogic.balanceOf(testreceiver.web3Contract._address), 2);
            }));
            it('should return the certificate #4 again', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield certificateLogic.getCertificate(4);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 4);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 1);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, testreceiver.web3Contract._address);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, []);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should be able to transfer token again', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield testreceiver.safeTransferFrom(testreceiver.web3Contract._address, testreceiver.web3Contract._address, 4, '0x01', {
                    privateKey: traderPK,
                });
                const cert = yield certificateLogic.getCertificate(4);
                //   if (isGanache) {
                const allTransferEvents = yield certificateLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                    0: testreceiver.web3Contract._address,
                    1: testreceiver.web3Contract._address,
                    2: '4',
                    _from: testreceiver.web3Contract._address,
                    _to: testreceiver.web3Contract._address,
                    _tokenId: '4',
                });
                //   }
                const retireEvent = yield certificateLogic.getAllLogCertificateRetiredEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(retireEvent.length, 1);
                chai_1.assert.equal(retireEvent[0].event, 'LogCertificateRetired');
                chai_1.assert.deepEqual(retireEvent[0].returnValues, {
                    0: '4', 1: true, _certificateId: '4', _retire: true,
                });
                chai_1.assert.equal(yield certificateLogic.getCertificateListLength(), 5);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountAssetOwner), 2);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountTrader), 1);
                chai_1.assert.equal(yield certificateLogic.balanceOf(testreceiver.web3Contract._address), 2);
            }));
            it('should return the certificate #4 again', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield certificateLogic.getCertificate(4);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isTrue(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 4);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 2);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, testreceiver.web3Contract._address);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, []);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
        });
        describe('escrow and approval', () => {
            it('should set an escrow to the asset', () => __awaiter(this, void 0, void 0, function* () {
                yield assetRegistry.addMatcher(0, matcherAccount, { privateKey: assetOwnerPK });
                chai_1.assert.deepEqual(yield assetRegistry.getMatcher(0), ['0x1000000000000000000000000000000000000005', matcherAccount]);
            }));
            it('should return correct approval', () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.isFalse(yield certificateLogic.isApprovedForAll(accountAssetOwner, approvedAccount));
                chai_1.assert.isFalse(yield certificateLogic.isApprovedForAll(accountTrader, approvedAccount));
                const tx = yield certificateLogic.setApprovalForAll(approvedAccount, true, { privateKey: assetOwnerPK });
                chai_1.assert.isTrue(yield certificateLogic.isApprovedForAll(accountAssetOwner, approvedAccount));
                chai_1.assert.isFalse(yield certificateLogic.isApprovedForAll(accountTrader, approvedAccount));
                const allApprovalEvents = yield certificateLogic.getAllApprovalForAllEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allApprovalEvents.length, 1);
                chai_1.assert.equal(allApprovalEvents[0].event, 'ApprovalForAll');
                chai_1.assert.deepEqual(allApprovalEvents[0].returnValues, {
                    0: accountAssetOwner,
                    1: approvedAccount,
                    2: true,
                    _owner: accountAssetOwner,
                    _operator: approvedAccount,
                    _approved: true,
                });
            }));
            it('should add 2nd approval', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield certificateLogic.setApprovalForAll('0x1000000000000000000000000000000000000005', true, { privateKey: assetOwnerPK });
                const allApprovalEvents = yield certificateLogic.getAllApprovalForAllEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allApprovalEvents.length, 1);
                chai_1.assert.equal(allApprovalEvents[0].event, 'ApprovalForAll');
                chai_1.assert.deepEqual(allApprovalEvents[0].returnValues, {
                    0: accountAssetOwner,
                    1: '0x1000000000000000000000000000000000000005',
                    2: true,
                    _owner: accountAssetOwner,
                    _operator: '0x1000000000000000000000000000000000000005',
                    _approved: true,
                });
                chai_1.assert.isTrue(yield certificateLogic.isApprovedForAll(accountAssetOwner, approvedAccount));
                chai_1.assert.isTrue(yield certificateLogic.isApprovedForAll(accountAssetOwner, '0x1000000000000000000000000000000000000005'));
            }));
            it('should remove approval', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield certificateLogic.setApprovalForAll('0x1000000000000000000000000000000000000005', false, { privateKey: assetOwnerPK });
                const allApprovalEvents = yield certificateLogic.getAllApprovalForAllEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allApprovalEvents.length, 1);
                chai_1.assert.equal(allApprovalEvents[0].event, 'ApprovalForAll');
                chai_1.assert.deepEqual(allApprovalEvents[0].returnValues, {
                    0: accountAssetOwner,
                    1: '0x1000000000000000000000000000000000000005',
                    2: false,
                    _owner: accountAssetOwner,
                    _operator: '0x1000000000000000000000000000000000000005',
                    _approved: false,
                });
                chai_1.assert.isTrue(yield certificateLogic.isApprovedForAll(accountAssetOwner, approvedAccount));
                chai_1.assert.isFalse(yield certificateLogic.isApprovedForAll(accountAssetOwner, '0x1000000000000000000000000000000000000005'));
            }));
            it('should return correct getApproved', () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.equal(yield certificateLogic.getApproved(0), '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(yield certificateLogic.getApproved(1), '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(yield certificateLogic.getApproved(2), '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(yield certificateLogic.getApproved(3), '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(yield certificateLogic.getApproved(4), '0x0000000000000000000000000000000000000000');
                yield certificateLogic.approve('0x1000000000000000000000000000000000000005', 2, { privateKey: assetOwnerPK });
                chai_1.assert.equal(yield certificateLogic.getApproved(0), '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(yield certificateLogic.getApproved(1), '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(yield certificateLogic.getApproved(2), '0x1000000000000000000000000000000000000005');
                chai_1.assert.equal(yield certificateLogic.getApproved(3), '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(yield certificateLogic.getApproved(4), '0x0000000000000000000000000000000000000000');
            }));
            it('should throw when calling getApproved for a non valid token', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.getApproved(5);
                }
                catch (ex) {
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw trying to transfer old certificate with new matcher', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.transferFrom(accountAssetOwner, accountTrader, 2, { privateKey: matcherPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'user does not have the required role');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should log energy again (certificate #5)', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield assetRegistry.saveSmartMeterRead(0, 400, 'lastSmartMeterReadFileHash', { privateKey: assetSmartmeterPK });
                const event = (yield assetRegistry.getAllLogNewMeterReadEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber }))[0];
                chai_1.assert.equal(event.event, 'LogNewMeterRead');
                chai_1.assert.deepEqual(event.returnValues, {
                    0: '0',
                    1: '300',
                    2: '400',
                    _assetId: '0',
                    _oldMeterRead: '300',
                    _newMeterRead: '400',
                });
                // if (isGanache) {
                const allTransferEvents = yield certificateLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                    0: '0x0000000000000000000000000000000000000000',
                    1: accountAssetOwner,
                    2: '5',
                    _from: '0x0000000000000000000000000000000000000000',
                    _to: accountAssetOwner,
                    _tokenId: '5',
                });
                //   }
                chai_1.assert.equal(yield certificateLogic.getCertificateListLength(), 6);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountAssetOwner), 3);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountTrader), 1);
                chai_1.assert.equal(yield certificateLogic.balanceOf(testreceiver.web3Contract._address), 2);
            }));
            it('should return the certificate #5 again', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield certificateLogic.getCertificate(5);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 5);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 0);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, ['0x1000000000000000000000000000000000000005', matcherAccount]);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should throw trying to transfer old certificate with new matcher but missing role', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.transferFrom(accountAssetOwner, accountTrader, 5, { privateKey: matcherPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'user does not have the required role');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw trying to safeTransferFrom without data old certificate with new matcher but missing role', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    const tx = yield certificateLogic.safeTransferFrom(accountAssetOwner, testreceiver.web3Contract._address, 5, null, { privateKey: matcherPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'user does not have the required role');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw trying to safeTransferFrom with data old certificate with new matcher but missing role', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    const tx = yield certificateLogic.safeTransferFrom(accountAssetOwner, testreceiver.web3Contract._address, 5, '0x01', { privateKey: matcherPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'user does not have the required role');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should set matcherAccount roles', () => __awaiter(this, void 0, void 0, function* () {
                yield userLogic.setUser(matcherAccount, 'matcherAccount', { privateKey: privateKeyDeployment });
                yield userLogic.setRoles(matcherAccount, 16, { privateKey: privateKeyDeployment });
            }));
            it('should transfer certificate #5 as matcher', () => __awaiter(this, void 0, void 0, function* () {
                // console.log(await certificateLogic.checkMatcher((await assetRegistry.getMatcher(5) as any)));
                chai_1.assert.equal(yield certificateLogic.getApproved(5), '0x0000000000000000000000000000000000000000');
                const tx = yield certificateLogic.transferFrom(accountAssetOwner, accountTrader, 5, { privateKey: matcherPK });
                // if (isGanache) {
                const allTransferEvents = yield certificateLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                    0: accountAssetOwner,
                    1: accountTrader,
                    2: '5',
                    _from: accountAssetOwner,
                    _to: accountTrader,
                    _tokenId: '5',
                });
                //   }
                chai_1.assert.equal(yield certificateLogic.getCertificateListLength(), 6);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountAssetOwner), 2);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountTrader), 2);
                chai_1.assert.equal(yield certificateLogic.balanceOf(testreceiver.web3Contract._address), 2);
                chai_1.assert.equal(yield certificateLogic.getApproved(5), '0x0000000000000000000000000000000000000000');
            }));
            it('should throw trying to call transer certificate #5 with matcher after it has been transfered', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.transferFrom(accountTrader, accountTrader, 5, { privateKey: matcherPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'simpleTransfer, missing rights');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should log energy again (certificate #6)', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield assetRegistry.saveSmartMeterRead(0, 500, 'lastSmartMeterReadFileHash', { privateKey: assetSmartmeterPK });
                const event = (yield assetRegistry.getAllLogNewMeterReadEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber }))[0];
                chai_1.assert.equal(event.event, 'LogNewMeterRead');
                chai_1.assert.deepEqual(event.returnValues, {
                    0: '0',
                    1: '400',
                    2: '500',
                    _assetId: '0',
                    _oldMeterRead: '400',
                    _newMeterRead: '500',
                });
                //  if (isGanache) {
                const allTransferEvents = yield certificateLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                    0: '0x0000000000000000000000000000000000000000',
                    1: accountAssetOwner,
                    2: '6',
                    _from: '0x0000000000000000000000000000000000000000',
                    _to: accountAssetOwner,
                    _tokenId: '6',
                });
                //  }
                chai_1.assert.equal(yield certificateLogic.getCertificateListLength(), 7);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountAssetOwner), 3);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountTrader), 2);
                chai_1.assert.equal(yield certificateLogic.balanceOf(testreceiver.web3Contract._address), 2);
            }));
            it('should transferFrom without data certificate #6 as matcher', () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.equal(yield certificateLogic.getApproved(6), '0x0000000000000000000000000000000000000000');
                const tx = yield certificateLogic.safeTransferFrom(accountAssetOwner, testreceiver.web3Contract._address, 6, null, { privateKey: matcherPK });
                // if (isGanache) {
                const allTransferEvents = yield certificateLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                    0: accountAssetOwner,
                    1: testreceiver.web3Contract._address,
                    2: '6',
                    _from: accountAssetOwner,
                    _to: testreceiver.web3Contract._address,
                    _tokenId: '6',
                });
                //   }
                chai_1.assert.equal(yield certificateLogic.getCertificateListLength(), 7);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountAssetOwner), 2);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountTrader), 2);
                chai_1.assert.equal(yield certificateLogic.balanceOf(testreceiver.web3Contract._address), 3);
                chai_1.assert.equal(yield certificateLogic.getApproved(6), '0x0000000000000000000000000000000000000000');
            }));
            it('should log energy again (certificate #7)', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield assetRegistry.saveSmartMeterRead(0, 600, 'lastSmartMeterReadFileHash', { privateKey: assetSmartmeterPK });
                const event = (yield assetRegistry.getAllLogNewMeterReadEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber }))[0];
                chai_1.assert.equal(event.event, 'LogNewMeterRead');
                chai_1.assert.deepEqual(event.returnValues, {
                    0: '0',
                    1: '500',
                    2: '600',
                    _assetId: '0',
                    _oldMeterRead: '500',
                    _newMeterRead: '600',
                });
                //  if (isGanache) {
                const allTransferEvents = yield certificateLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                    0: '0x0000000000000000000000000000000000000000',
                    1: accountAssetOwner,
                    2: '7',
                    _from: '0x0000000000000000000000000000000000000000',
                    _to: accountAssetOwner,
                    _tokenId: '7',
                });
                //   }
                chai_1.assert.equal(yield certificateLogic.getCertificateListLength(), 8);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountAssetOwner), 3);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountTrader), 2);
                chai_1.assert.equal(yield certificateLogic.balanceOf(testreceiver.web3Contract._address), 3);
            }));
            it('should transfer without data certificate #7 as matcher', () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.equal(yield certificateLogic.getApproved(7), '0x0000000000000000000000000000000000000000');
                const tx = yield certificateLogic.safeTransferFrom(accountAssetOwner, testreceiver.web3Contract._address, 7, '0x01', { privateKey: matcherPK });
                //  if (isGanache) {
                const allTransferEvents = yield certificateLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                    0: accountAssetOwner,
                    1: testreceiver.web3Contract._address,
                    2: '7',
                    _from: accountAssetOwner,
                    _to: testreceiver.web3Contract._address,
                    _tokenId: '7',
                });
                //   }
                chai_1.assert.equal(yield certificateLogic.getCertificateListLength(), 8);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountAssetOwner), 2);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountTrader), 2);
                chai_1.assert.equal(yield certificateLogic.balanceOf(testreceiver.web3Contract._address), 4);
                chai_1.assert.equal(yield certificateLogic.getApproved(7), '0x0000000000000000000000000000000000000000');
            }));
            it('should log energy again (certificate #8)', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield assetRegistry.saveSmartMeterRead(0, 700, 'lastSmartMeterReadFileHash', { privateKey: assetSmartmeterPK });
                const event = (yield assetRegistry.getAllLogNewMeterReadEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber }))[0];
                chai_1.assert.equal(event.event, 'LogNewMeterRead');
                chai_1.assert.deepEqual(event.returnValues, {
                    0: '0',
                    1: '600',
                    2: '700',
                    _assetId: '0',
                    _oldMeterRead: '600',
                    _newMeterRead: '700',
                });
                //  if (isGanache) {
                const allTransferEvents = yield certificateLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                    0: '0x0000000000000000000000000000000000000000',
                    1: accountAssetOwner,
                    2: '8',
                    _from: '0x0000000000000000000000000000000000000000',
                    _to: accountAssetOwner,
                    _tokenId: '8',
                });
                //   }
                chai_1.assert.equal(yield certificateLogic.getCertificateListLength(), 9);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountAssetOwner), 3);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountTrader), 2);
                chai_1.assert.equal(yield certificateLogic.balanceOf(testreceiver.web3Contract._address), 4);
            }));
            it('should throw trying to transfer old certificate#8 with new matcher but missing role', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.transferFrom(accountAssetOwner, accountTrader, 8, { privateKey: approvedPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'user does not have the required role');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw trying to safeTransferFrom without data old certificate#8 with new approvedAccount but missing role', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    const tx = yield certificateLogic.safeTransferFrom(accountAssetOwner, testreceiver.web3Contract._address, 8, null, { privateKey: approvedPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'user does not have the required role');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw trying to safeTransferFrom with data old certificate#8 with new approvedAccount but missing role', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    const tx = yield certificateLogic.safeTransferFrom(accountAssetOwner, testreceiver.web3Contract._address, 8, '0x01', { privateKey: approvedPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'user does not have the required role');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should set approvedAccount roles', () => __awaiter(this, void 0, void 0, function* () {
                yield userLogic.setUser(approvedAccount, 'approvedAccount', { privateKey: privateKeyDeployment });
                yield userLogic.setRoles(approvedAccount, 16, { privateKey: privateKeyDeployment });
            }));
            it('should transfer certificate#8 with approved account', () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.equal(yield certificateLogic.getApproved(8), '0x0000000000000000000000000000000000000000');
                const tx = yield certificateLogic.transferFrom(accountAssetOwner, accountTrader, 8, { privateKey: approvedPK });
                //   if (isGanache) {
                const allTransferEvents = yield certificateLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                    0: accountAssetOwner,
                    1: accountTrader,
                    2: '8',
                    _from: accountAssetOwner,
                    _to: accountTrader,
                    _tokenId: '8',
                });
                //   }
                chai_1.assert.equal(yield certificateLogic.getCertificateListLength(), 9);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountAssetOwner), 2);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountTrader), 3);
                chai_1.assert.equal(yield certificateLogic.balanceOf(testreceiver.web3Contract._address), 4);
                chai_1.assert.equal(yield certificateLogic.getApproved(8), '0x0000000000000000000000000000000000000000');
            }));
            it('should log energy again (certificate #9)', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield assetRegistry.saveSmartMeterRead(0, 800, 'lastSmartMeterReadFileHash', { privateKey: assetSmartmeterPK });
                const event = (yield assetRegistry.getAllLogNewMeterReadEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber }))[0];
                chai_1.assert.equal(event.event, 'LogNewMeterRead');
                chai_1.assert.deepEqual(event.returnValues, {
                    0: '0',
                    1: '700',
                    2: '800',
                    _assetId: '0',
                    _oldMeterRead: '700',
                    _newMeterRead: '800',
                });
                //    if (isGanache) {
                const allTransferEvents = yield certificateLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                    0: '0x0000000000000000000000000000000000000000',
                    1: accountAssetOwner,
                    2: '9',
                    _from: '0x0000000000000000000000000000000000000000',
                    _to: accountAssetOwner,
                    _tokenId: '9',
                });
                //    }
                chai_1.assert.equal(yield certificateLogic.getCertificateListLength(), 10);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountAssetOwner), 3);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountTrader), 3);
                chai_1.assert.equal(yield certificateLogic.balanceOf(testreceiver.web3Contract._address), 4);
            }));
            it('should safeTransferFrom without data certificate #9 as approved', () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.equal(yield certificateLogic.getApproved(9), '0x0000000000000000000000000000000000000000');
                const tx = yield certificateLogic.safeTransferFrom(accountAssetOwner, testreceiver.web3Contract._address, 9, null, { privateKey: approvedPK });
                //   if (isGanache) {
                const allTransferEvents = yield certificateLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                    0: accountAssetOwner,
                    1: testreceiver.web3Contract._address,
                    2: '9',
                    _from: accountAssetOwner,
                    _to: testreceiver.web3Contract._address,
                    _tokenId: '9',
                });
                //    }
                chai_1.assert.equal(yield certificateLogic.getCertificateListLength(), 10);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountAssetOwner), 2);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountTrader), 3);
                chai_1.assert.equal(yield certificateLogic.balanceOf(testreceiver.web3Contract._address), 5);
                chai_1.assert.equal(yield certificateLogic.getApproved(9), '0x0000000000000000000000000000000000000000');
            }));
            it('should log energy again (certificate #10)', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield assetRegistry.saveSmartMeterRead(0, 900, 'lastSmartMeterReadFileHash', { privateKey: assetSmartmeterPK });
                const event = (yield assetRegistry.getAllLogNewMeterReadEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber }))[0];
                chai_1.assert.equal(event.event, 'LogNewMeterRead');
                chai_1.assert.deepEqual(event.returnValues, {
                    0: '0',
                    1: '800',
                    2: '900',
                    _assetId: '0',
                    _oldMeterRead: '800',
                    _newMeterRead: '900',
                });
                // if (isGanache) {
                const allTransferEvents = yield certificateLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                    0: '0x0000000000000000000000000000000000000000',
                    1: accountAssetOwner,
                    2: '10',
                    _from: '0x0000000000000000000000000000000000000000',
                    _to: accountAssetOwner,
                    _tokenId: '10',
                });
                //   }
                chai_1.assert.equal(yield certificateLogic.getCertificateListLength(), 11);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountAssetOwner), 3);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountTrader), 3);
                chai_1.assert.equal(yield certificateLogic.balanceOf(testreceiver.web3Contract._address), 5);
            }));
            it('should safeTransferFrom with data certificate #10 as approved', () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.equal(yield certificateLogic.getApproved(10), '0x0000000000000000000000000000000000000000');
                const tx = yield certificateLogic.safeTransferFrom(accountAssetOwner, testreceiver.web3Contract._address, 10, '0x01', { privateKey: approvedPK });
                //  if (isGanache) {
                const allTransferEvents = yield certificateLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                    0: accountAssetOwner,
                    1: testreceiver.web3Contract._address,
                    2: '10',
                    _from: accountAssetOwner,
                    _to: testreceiver.web3Contract._address,
                    _tokenId: '10',
                });
                //     }
                chai_1.assert.equal(yield certificateLogic.getCertificateListLength(), 11);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountAssetOwner), 2);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountTrader), 3);
                chai_1.assert.equal(yield certificateLogic.balanceOf(testreceiver.web3Contract._address), 6);
                chai_1.assert.equal(yield certificateLogic.getApproved(9), '0x0000000000000000000000000000000000000000');
            }));
            it('should log energy again (certificate #11)', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield assetRegistry.saveSmartMeterRead(0, 1000, 'lastSmartMeterReadFileHash', { privateKey: assetSmartmeterPK });
                const event = (yield assetRegistry.getAllLogNewMeterReadEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber }))[0];
                chai_1.assert.equal(event.event, 'LogNewMeterRead');
                chai_1.assert.deepEqual(event.returnValues, {
                    0: '0',
                    1: '900',
                    2: '1000',
                    _assetId: '0',
                    _oldMeterRead: '900',
                    _newMeterRead: '1000',
                });
                //    if (isGanache) {
                const allTransferEvents = yield certificateLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                    0: '0x0000000000000000000000000000000000000000',
                    1: accountAssetOwner,
                    2: '11',
                    _from: '0x0000000000000000000000000000000000000000',
                    _to: accountAssetOwner,
                    _tokenId: '11',
                });
                //    }
                chai_1.assert.equal(yield certificateLogic.getCertificateListLength(), 12);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountAssetOwner), 3);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountTrader), 3);
                chai_1.assert.equal(yield certificateLogic.balanceOf(testreceiver.web3Contract._address), 6);
            }));
            it('should fail when trying to approve cert#11 as admin', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.approve(approvedAccount, 11, { privateKey: privateKeyDeployment });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'approve: not owner / matcher');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should fail when trying to approve cert#11 as trader', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.approve(approvedAccount, 11, { privateKey: traderPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'approve: not owner / matcher');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should be able to approve as cert-owner', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield certificateLogic.approve(approvedAccount, 11, { privateKey: assetOwnerPK });
                //   if (isGanache) {
                const allApprovedEvents = yield certificateLogic.getAllApprovalEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allApprovedEvents.length, 1);
                chai_1.assert.equal(allApprovedEvents[0].event, 'Approval');
                chai_1.assert.deepEqual(allApprovedEvents[0].returnValues, {
                    0: accountAssetOwner,
                    1: approvedAccount,
                    2: '11',
                    _owner: accountAssetOwner,
                    _approved: approvedAccount,
                    _tokenId: '11',
                });
                //    }
            }));
            it('should call transferFrom with cert#11 with approved account', () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.equal(yield certificateLogic.getApproved(11), approvedAccount);
                const tx = yield certificateLogic.transferFrom(accountAssetOwner, accountTrader, 11, { privateKey: approvedPK });
                //    if (isGanache) {
                const allTransferEvents = yield certificateLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                    0: accountAssetOwner,
                    1: accountTrader,
                    2: '11',
                    _from: accountAssetOwner,
                    _to: accountTrader,
                    _tokenId: '11',
                });
                //  }
                chai_1.assert.equal(yield certificateLogic.getCertificateListLength(), 12);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountAssetOwner), 2);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountTrader), 4);
                chai_1.assert.equal(yield certificateLogic.balanceOf(testreceiver.web3Contract._address), 6);
                chai_1.assert.equal(yield certificateLogic.getApproved(11), '0x0000000000000000000000000000000000000000');
            }));
            it('should log energy again (certificate #12)', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield assetRegistry.saveSmartMeterRead(0, 1100, 'lastSmartMeterReadFileHash', { privateKey: assetSmartmeterPK });
                const event = (yield assetRegistry.getAllLogNewMeterReadEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber }))[0];
                chai_1.assert.equal(event.event, 'LogNewMeterRead');
                chai_1.assert.deepEqual(event.returnValues, {
                    0: '0',
                    1: '1000',
                    2: '1100',
                    _assetId: '0',
                    _oldMeterRead: '1000',
                    _newMeterRead: '1100',
                });
                // if (isGanache) {
                const allTransferEvents = yield certificateLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                    0: '0x0000000000000000000000000000000000000000',
                    1: accountAssetOwner,
                    2: '12',
                    _from: '0x0000000000000000000000000000000000000000',
                    _to: accountAssetOwner,
                    _tokenId: '12',
                });
                //   }
                chai_1.assert.equal(yield certificateLogic.getCertificateListLength(), 13);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountAssetOwner), 3);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountTrader), 4);
                chai_1.assert.equal(yield certificateLogic.balanceOf(testreceiver.web3Contract._address), 6);
            }));
            it('should be able to approve cert#12 as cert-owner', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield certificateLogic.approve(approvedAccount, 12, { privateKey: assetOwnerPK });
                //    if (isGanache) {
                const allApprovedEvents = yield certificateLogic.getAllApprovalEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allApprovedEvents.length, 1);
                chai_1.assert.equal(allApprovedEvents[0].event, 'Approval');
                chai_1.assert.deepEqual(allApprovedEvents[0].returnValues, {
                    0: accountAssetOwner,
                    1: approvedAccount,
                    2: '12',
                    _owner: accountAssetOwner,
                    _approved: approvedAccount,
                    _tokenId: '12',
                });
                //    }
            }));
            it('should safeTransferFrom withut data certificate #12 as approved', () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.equal(yield certificateLogic.getApproved(12), approvedAccount);
                const tx = yield certificateLogic.safeTransferFrom(accountAssetOwner, testreceiver.web3Contract._address, 12, null, { privateKey: approvedPK });
                //  if (isGanache) {
                const allTransferEvents = yield certificateLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                    0: accountAssetOwner,
                    1: testreceiver.web3Contract._address,
                    2: '12',
                    _from: accountAssetOwner,
                    _to: testreceiver.web3Contract._address,
                    _tokenId: '12',
                });
                //   }
                chai_1.assert.equal(yield certificateLogic.getCertificateListLength(), 13);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountAssetOwner), 2);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountTrader), 4);
                chai_1.assert.equal(yield certificateLogic.balanceOf(testreceiver.web3Contract._address), 7);
                chai_1.assert.equal(yield certificateLogic.getApproved(9), '0x0000000000000000000000000000000000000000');
            }));
            it('should log energy again (certificate #13)', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield assetRegistry.saveSmartMeterRead(0, 1200, 'lastSmartMeterReadFileHash', { privateKey: assetSmartmeterPK });
                const event = (yield assetRegistry.getAllLogNewMeterReadEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber }))[0];
                chai_1.assert.equal(event.event, 'LogNewMeterRead');
                chai_1.assert.deepEqual(event.returnValues, {
                    0: '0',
                    1: '1100',
                    2: '1200',
                    _assetId: '0',
                    _oldMeterRead: '1100',
                    _newMeterRead: '1200',
                });
                //  if (isGanache) {
                const allTransferEvents = yield certificateLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                    0: '0x0000000000000000000000000000000000000000',
                    1: accountAssetOwner,
                    2: '13',
                    _from: '0x0000000000000000000000000000000000000000',
                    _to: accountAssetOwner,
                    _tokenId: '13',
                });
                //   }
                chai_1.assert.equal(yield certificateLogic.getCertificateListLength(), 14);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountAssetOwner), 3);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountTrader), 4);
                chai_1.assert.equal(yield certificateLogic.balanceOf(testreceiver.web3Contract._address), 7);
            }));
            it('should be able to approve cert#13 as cert-owner', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield certificateLogic.approve(approvedAccount, 13, { privateKey: assetOwnerPK });
                //     if (isGanache) {
                const allApprovedEvents = yield certificateLogic.getAllApprovalEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allApprovedEvents.length, 1);
                chai_1.assert.equal(allApprovedEvents[0].event, 'Approval');
                chai_1.assert.deepEqual(allApprovedEvents[0].returnValues, {
                    0: accountAssetOwner,
                    1: approvedAccount,
                    2: '13',
                    _owner: accountAssetOwner,
                    _approved: approvedAccount,
                    _tokenId: '13',
                });
                //  }
            }));
            it('should safeTransferFrom withut data certificate #13 as approved', () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.equal(yield certificateLogic.getApproved(13), approvedAccount);
                const tx = yield certificateLogic.safeTransferFrom(accountAssetOwner, testreceiver.web3Contract._address, 13, null, { privateKey: approvedPK });
                //   if (isGanache) {
                const allTransferEvents = yield certificateLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                    0: accountAssetOwner,
                    1: testreceiver.web3Contract._address,
                    2: '13',
                    _from: accountAssetOwner,
                    _to: testreceiver.web3Contract._address,
                    _tokenId: '13',
                });
                //   }
                chai_1.assert.equal(yield certificateLogic.getCertificateListLength(), 14);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountAssetOwner), 2);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountTrader), 4);
                chai_1.assert.equal(yield certificateLogic.balanceOf(testreceiver.web3Contract._address), 8);
                chai_1.assert.equal(yield certificateLogic.getApproved(13), '0x0000000000000000000000000000000000000000');
            }));
            it('should be able to burn (to = 0x0) a certificate', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield certificateLogic.transferFrom(accountTrader, '0x0000000000000000000000000000000000000000', 11, { privateKey: traderPK });
                // if (isGanache) {
                const allTransferEvents = yield certificateLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                    0: accountTrader,
                    1: '0x0000000000000000000000000000000000000000',
                    2: '11',
                    _from: accountTrader,
                    _to: '0x0000000000000000000000000000000000000000',
                    _tokenId: '11',
                });
                //  }
                chai_1.assert.equal(yield certificateLogic.getCertificateListLength(), 14);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountAssetOwner), 2);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountTrader), 3);
                chai_1.assert.equal(yield certificateLogic.balanceOf(testreceiver.web3Contract._address), 8);
                chai_1.assert.equal(yield certificateLogic.getApproved(13), '0x0000000000000000000000000000000000000000');
            }));
            it('should log energy again (certificate #14)', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield assetRegistry.saveSmartMeterRead(0, 1300, 'lastSmartMeterReadFileHash', { privateKey: assetSmartmeterPK });
                const event = (yield assetRegistry.getAllLogNewMeterReadEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber }))[0];
                chai_1.assert.equal(event.event, 'LogNewMeterRead');
                chai_1.assert.deepEqual(event.returnValues, {
                    0: '0',
                    1: '1200',
                    2: '1300',
                    _assetId: '0',
                    _oldMeterRead: '1200',
                    _newMeterRead: '1300',
                });
                //     if (isGanache) {
                const allTransferEvents = yield certificateLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                    0: '0x0000000000000000000000000000000000000000',
                    1: accountAssetOwner,
                    2: '14',
                    _from: '0x0000000000000000000000000000000000000000',
                    _to: accountAssetOwner,
                    _tokenId: '14',
                });
                //  }
                chai_1.assert.equal(yield certificateLogic.getCertificateListLength(), 15);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountAssetOwner), 3);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountTrader), 3);
                chai_1.assert.equal(yield certificateLogic.balanceOf(testreceiver.web3Contract._address), 8);
            }));
            it('should fail when trying to retire cert#14 as admin', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.retireCertificate(14, { privateKey: accountDeployment });
                }
                catch (ex) {
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should fail when trying to retire cert#14 as trader', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.retireCertificate(14, { privateKey: traderPK });
                }
                catch (ex) {
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should retire cert#14 as owner', () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.isFalse(yield certificateLogic.isRetired(14));
                const tx = yield certificateLogic.retireCertificate(14, { privateKey: assetOwnerPK });
                chai_1.assert.isTrue(yield certificateLogic.isRetired(14));
                const retiredEvents = yield certificateLogic.getAllLogCertificateRetiredEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(retiredEvents.length, 1);
                chai_1.assert.equal(retiredEvents[0].event, 'LogCertificateRetired');
                chai_1.assert.deepEqual(retiredEvents[0].returnValues, {
                    0: '14', 1: true, _certificateId: '14', _retire: true,
                });
            }));
            it('should be able to call retire cert#14 as owner, but no event', () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.isTrue(yield certificateLogic.isRetired(14));
                const tx = yield certificateLogic.retireCertificate(14, { privateKey: assetOwnerPK });
                chai_1.assert.isTrue(yield certificateLogic.isRetired(14));
                const retiredEvents = yield certificateLogic.getAllLogCertificateRetiredEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(retiredEvents.length, 0);
            }));
            it('should throw when trying to retire a splitted certificate', () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.isFalse(yield certificateLogic.isRetired(0));
                let failed = false;
                try {
                    yield certificateLogic.retireCertificate(0, { privateKey: accountAssetOwner });
                }
                catch (ex) {
                    failed = true;
                }
                chai_1.assert.isTrue(failed);
            }));
        });
        describe('ERC20', () => {
            it('should have correct balanes', () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.equal(yield erc20Test.balanceOf(accountTrader), 1000000);
                chai_1.assert.equal(yield erc20Test.balanceOf(accountDeployment), 99999999999999000000);
                chai_1.assert.equal(yield erc20Test.balanceOf(accountAssetOwner), 0);
            }));
            it('should log energy again (certificate #15)', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield assetRegistry.saveSmartMeterRead(0, 1400, 'lastSmartMeterReadFileHash', { privateKey: assetSmartmeterPK });
                const event = (yield assetRegistry.getAllLogNewMeterReadEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber }))[0];
                chai_1.assert.equal(event.event, 'LogNewMeterRead');
                chai_1.assert.deepEqual(event.returnValues, {
                    0: '0',
                    1: '1300',
                    2: '1400',
                    _assetId: '0',
                    _oldMeterRead: '1300',
                    _newMeterRead: '1400',
                });
                // if (isGanache) {
                const allTransferEvents = yield certificateLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                    0: '0x0000000000000000000000000000000000000000',
                    1: accountAssetOwner,
                    2: '15',
                    _from: '0x0000000000000000000000000000000000000000',
                    _to: accountAssetOwner,
                    _tokenId: '15',
                });
                //  }
                chai_1.assert.equal(yield certificateLogic.getCertificateListLength(), 16);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountAssetOwner), 4);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountTrader), 3);
                chai_1.assert.equal(yield certificateLogic.balanceOf(testreceiver.web3Contract._address), 8);
            }));
            it('should not have an acceptedToken after creation', () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.equal(yield certificateLogic.getTradableToken(15), '0x0000000000000000000000000000000000000000');
            }));
            it('should not have a tokenprice', () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.equal(yield certificateLogic.getOnChainDirectPurchasePrice(15), 0);
            }));
            it('should fail when trying to set tradableToken as admin', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.setTradableToken(15, erc20Test.web3Contract._address, { privateKey: privateKeyDeployment });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'not the enitity-owner');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should fail when trying to set tradableToken as trader', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.setTradableToken(15, erc20Test.web3Contract._address, { privateKey: traderPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'not the enitity-owner');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should set tradableToken as owner', () => __awaiter(this, void 0, void 0, function* () {
                yield certificateLogic.setTradableToken(15, erc20Test.web3Contract._address, { privateKey: assetOwnerPK });
                chai_1.assert.equal(yield certificateLogic.getTradableToken(15), erc20Test.web3Contract._address);
            }));
            it('should fail when trying to buy a token with a price of 0', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.buyCertificate(15, { privateKey: traderPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'erc20 transfer failed');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should fail when trying to set the onchainPrice as admin', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.setOnChainDirectPurchasePrice(15, 1000, { privateKey: privateKeyDeployment });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'not the enitity-owner');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should fail when trying to set the onchainPrice as trader', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.setOnChainDirectPurchasePrice(15, 1000, { privateKey: traderPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'not the enitity-owner');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should set the onchainPrice as certOwner', () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.equal(yield certificateLogic.getOnChainDirectPurchasePrice(15), 0);
                yield certificateLogic.setOnChainDirectPurchasePrice(15, 100, { privateKey: assetOwnerPK });
                chai_1.assert.equal(yield certificateLogic.getOnChainDirectPurchasePrice(15), 100);
            }));
            it('should return the certificate #15', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield certificateLogic.getCertificate(15);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 15);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 0);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, erc20Test.web3Contract._address);
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 100);
                chai_1.assert.deepEqual(tradableEntity.escrow, ['0x1000000000000000000000000000000000000005', matcherAccount]);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should return the correct tradableEntity (Cert#15)', () => __awaiter(this, void 0, void 0, function* () {
                const tradableEntity = yield certificateLogic.getTradableEntity(15);
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, erc20Test.web3Contract._address);
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 100);
                chai_1.assert.deepEqual(tradableEntity.escrow, ['0x1000000000000000000000000000000000000005', matcherAccount]);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should fail when trying to buy a token when the tokens are not approved', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.buyCertificate(15, { privateKey: traderPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'erc20 transfer failed');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should fail when trying to buy a token when not enough tokens are not approved', () => __awaiter(this, void 0, void 0, function* () {
                yield erc20Test.approve(accountAssetOwner, 99, { privateKey: traderPK });
                let failed = false;
                try {
                    yield certificateLogic.buyCertificate(15, { privateKey: traderPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'erc20 transfer failed');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should be able to buy a certficate', () => __awaiter(this, void 0, void 0, function* () {
                yield erc20Test.approve(accountAssetOwner, 100, { privateKey: traderPK });
                const tx = yield certificateLogic.buyCertificate(15, { privateKey: traderPK });
                //  if (isGanache) {
                const allTransferEvents = yield certificateLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                    0: accountAssetOwner,
                    1: accountTrader,
                    2: '15',
                    _from: accountAssetOwner,
                    _to: accountTrader,
                    _tokenId: '15',
                });
                //  }
                chai_1.assert.equal(yield certificateLogic.getCertificateListLength(), 16);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountAssetOwner), 3);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountTrader), 4);
                chai_1.assert.equal(yield certificateLogic.balanceOf(testreceiver.web3Contract._address), 8);
            }));
            it('should return the correct tradableEntity (Cert#15)', () => __awaiter(this, void 0, void 0, function* () {
                const tradableEntity = yield certificateLogic.getTradableEntity(15);
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountTrader);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, []);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should return the certificate #15', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield certificateLogic.getCertificate(15);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 15);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 1);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountTrader);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, []);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should log energy again (certificate #16)', () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield assetRegistry.saveSmartMeterRead(0, 1500, 'lastSmartMeterReadFileHash', { privateKey: assetSmartmeterPK });
                const event = (yield assetRegistry.getAllLogNewMeterReadEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber }))[0];
                chai_1.assert.equal(event.event, 'LogNewMeterRead');
                chai_1.assert.deepEqual(event.returnValues, {
                    0: '0',
                    1: '1400',
                    2: '1500',
                    _assetId: '0',
                    _oldMeterRead: '1400',
                    _newMeterRead: '1500',
                });
                //  if (isGanache) {
                const allTransferEvents = yield certificateLogic.getAllTransferEvents({ fromBlock: tx.blockNumber, toBlock: tx.blockNumber });
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents.length, 1);
                chai_1.assert.equal(allTransferEvents[0].event, 'Transfer');
                chai_1.assert.deepEqual(allTransferEvents[0].returnValues, {
                    0: '0x0000000000000000000000000000000000000000',
                    1: accountAssetOwner,
                    2: '16',
                    _from: '0x0000000000000000000000000000000000000000',
                    _to: accountAssetOwner,
                    _tokenId: '16',
                });
                //    }
                chai_1.assert.equal(yield certificateLogic.getCertificateListLength(), 17);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountAssetOwner), 4);
                chai_1.assert.equal(yield certificateLogic.balanceOf(accountTrader), 4);
                chai_1.assert.equal(yield certificateLogic.balanceOf(testreceiver.web3Contract._address), 8);
            }));
            it('should return the correct tradableEntity (Cert#16)', () => __awaiter(this, void 0, void 0, function* () {
                const tradableEntity = yield certificateLogic.getTradableEntity(16);
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, ['0x1000000000000000000000000000000000000005', matcherAccount]);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should throw when trying to remove not existing escrow as admin', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.removeEscrow(16, '0x1000000000000000000000000000000000000004', { privateKey: privateKeyDeployment });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'not the enitity-owner');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to remove not existing escrow as trader', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.removeEscrow(16, '0x1000000000000000000000000000000000000004', { privateKey: traderPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'not the enitity-owner');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to remove not existing escrow as owner', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.removeEscrow(16, '0x1000000000000000000000000000000000000004', { privateKey: assetOwnerPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'escrow address not in array');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to remove existing escrow as admin', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.removeEscrow(16, '0x1000000000000000000000000000000000000005', { privateKey: privateKeyDeployment });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'not the enitity-owner');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to remove existing escrow as trader', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.removeEscrow(16, '0x1000000000000000000000000000000000000005', { privateKey: traderPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'not the enitity-owner');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should remove existing escrow', () => __awaiter(this, void 0, void 0, function* () {
                yield certificateLogic.removeEscrow(16, '0x1000000000000000000000000000000000000005', { privateKey: assetOwnerPK });
            }));
            it('should return the correct tradableEntity (Cert#16)', () => __awaiter(this, void 0, void 0, function* () {
                const tradableEntity = yield certificateLogic.getTradableEntity(16);
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, [matcherAccount]);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should return the certificate #16', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield certificateLogic.getCertificate(16);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 16);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 0);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, [matcherAccount]);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should remove remaining escrow', () => __awaiter(this, void 0, void 0, function* () {
                yield certificateLogic.removeEscrow(16, matcherAccount, { privateKey: assetOwnerPK });
            }));
            it('should return the correct tradableEntity (Cert#16)', () => __awaiter(this, void 0, void 0, function* () {
                const tradableEntity = yield certificateLogic.getTradableEntity(16);
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, []);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should return the certificate #16', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield certificateLogic.getCertificate(16);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 16);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 0);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, []);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should throw when trying to add escrow as trader', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.addEscrowForEntity(16, '0x1000000000000000000000000000000000000000', { privateKey: traderPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'not the enitity-owner');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should throw when trying to add escrow as admin', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.addEscrowForEntity(16, '0x1000000000000000000000000000000000000000', { privateKey: privateKeyDeployment });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'not the enitity-owner');
                }
                chai_1.assert.isTrue(failed);
            }));
            it('should add escrow as owner of cert', () => __awaiter(this, void 0, void 0, function* () {
                yield certificateLogic.addEscrowForEntity(16, '0x1000000000000000000000000000000000000000', { privateKey: assetOwnerPK });
            }));
            it('should add more escrows as owner of cert', () => __awaiter(this, void 0, void 0, function* () {
                for (let i = 1; i < 10; i++) {
                    yield certificateLogic.addEscrowForEntity(16, '0x100000000000000000000000000000000000000' + i, { privateKey: assetOwnerPK });
                }
            }));
            it('should return the correct tradableEntity (Cert#16)', () => __awaiter(this, void 0, void 0, function* () {
                const tradableEntity = yield certificateLogic.getTradableEntity(16);
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, ['0x1000000000000000000000000000000000000000',
                    '0x1000000000000000000000000000000000000001',
                    '0x1000000000000000000000000000000000000002',
                    '0x1000000000000000000000000000000000000003',
                    '0x1000000000000000000000000000000000000004',
                    '0x1000000000000000000000000000000000000005',
                    '0x1000000000000000000000000000000000000006',
                    '0x1000000000000000000000000000000000000007',
                    '0x1000000000000000000000000000000000000008',
                    '0x1000000000000000000000000000000000000009']);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should return the certificate #16', () => __awaiter(this, void 0, void 0, function* () {
                const cert = yield certificateLogic.getCertificate(16);
                const certificateSpecific = cert.certificateSpecific;
                chai_1.assert.isFalse(certificateSpecific.retired);
                chai_1.assert.equal(certificateSpecific.dataLog, 'lastSmartMeterReadFileHash');
                chai_1.assert.equal(certificateSpecific.parentId, 16);
                chai_1.assert.equal(certificateSpecific.children.length, 0);
                chai_1.assert.equal(certificateSpecific.maxOwnerChanges, 2);
                chai_1.assert.equal(certificateSpecific.ownerChangeCounter, 0);
                const tradableEntity = cert.tradableEntity;
                chai_1.assert.equal(tradableEntity.assetId, 0);
                chai_1.assert.equal(tradableEntity.owner, accountAssetOwner);
                chai_1.assert.equal(tradableEntity.powerInW, 100);
                chai_1.assert.equal(tradableEntity.acceptedToken, '0x0000000000000000000000000000000000000000');
                chai_1.assert.equal(tradableEntity.onChainDirectPurchasePrice, 0);
                chai_1.assert.deepEqual(tradableEntity.escrow, ['0x1000000000000000000000000000000000000000',
                    '0x1000000000000000000000000000000000000001',
                    '0x1000000000000000000000000000000000000002',
                    '0x1000000000000000000000000000000000000003',
                    '0x1000000000000000000000000000000000000004',
                    '0x1000000000000000000000000000000000000005',
                    '0x1000000000000000000000000000000000000006',
                    '0x1000000000000000000000000000000000000007',
                    '0x1000000000000000000000000000000000000008',
                    '0x1000000000000000000000000000000000000009']);
                chai_1.assert.equal(tradableEntity.approvedAddress, '0x0000000000000000000000000000000000000000');
            }));
            it('should throw when trying to add too much escrow', () => __awaiter(this, void 0, void 0, function* () {
                let failed = false;
                try {
                    yield certificateLogic.addEscrowForEntity(16, '0x1000000000000000000000000000000000000010', { privateKey: assetOwnerPK });
                }
                catch (ex) {
                    failed = true;
                    chai_1.assert.include(ex.message, 'maximum amount of escrows reached');
                }
                chai_1.assert.isTrue(failed);
            }));
        });
    });
});
//# sourceMappingURL=CertificateLogic.js.map