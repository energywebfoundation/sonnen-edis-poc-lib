"use strict";
// Copyright 2018 Energy Web Foundation
// This file is part of the Origin Application brought to you by the Energy Web Foundation,
// a global non-profit organization focused on accelerating blockchain technology across the energy sector,
// incorporated in Zug, Switzerland.
//
// The Origin Application is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// This is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY and without an implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details, at <http://www.gnu.org/licenses/>.
//
// @authors: slock.it GmbH; Heiko Burkhardt, heiko.burkhardt@slock.it; Martin Kuechler, martin.kuchler@slock.it
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ew_utils_general_precise_proofs_1 = require("ew-utils-general-precise-proofs");
const axios_1 = __importDefault(require("axios"));
const json_validator_1 = require("../off-chain-data/json-validator");
class Entity {
    constructor(id, configuration) {
        this.id = id;
        this.configuration = configuration;
        this.proofs = [];
    }
    addProof(proof) {
        this.proofs.push(proof);
    }
    prepareEntityCreation(onChainProperties, offChainProperties, schema, url, debug) {
        const axiosurl = url ? url : this.getUrl();
        json_validator_1.validateJson(offChainProperties, schema, axiosurl, this.configuration.logger);
        if (this.configuration.offChainDataSource) {
            if (onChainProperties.url) {
                throw new Error('URL should not be set');
            }
            if (onChainProperties.propertiesDocumentHash) {
                throw new Error('Hash should not be set');
            }
            return this.generateAndAddProofs(offChainProperties, debug);
        }
        return null;
    }
    putToOffChainStorage(properties, offChainStorageProperties, url) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.configuration.offChainDataSource) {
                const axiosurl = url ? url : this.getUrl();
                yield axios_1.default.put(`${axiosurl}/${this.id}`, {
                    properties,
                    salts: offChainStorageProperties.salts,
                    schema: offChainStorageProperties.schema,
                });
                if (this.configuration.logger) {
                    this.configuration.logger.verbose(`Put off chain properties to ${axiosurl}/${this.id}`);
                }
            }
        });
    }
    getOffChainProperties(hash, url, debug) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.configuration.offChainDataSource) {
                const axiosurl = url ? url : this.getUrl();
                const data = (yield axios_1.default.get(`${axiosurl}/${this.id}`)).data;
                const offChainProperties = data.properties;
                this.generateAndAddProofs(data.properties, debug, data.salts);
                this.verifyOffChainProperties(hash, offChainProperties, data.schema, debug);
                if (this.configuration.logger) {
                    this.configuration.logger.verbose(`Got off chain properties from ${axiosurl}/${this.id}`);
                }
                return offChainProperties;
            }
            return null;
        });
    }
    verifyOffChainProperties(rootHash, properties, schema, debug) {
        Object.keys(properties).map((key) => {
            const theProof = this.proofs.find((proof) => proof.key === key);
            if (debug) {
                console.log('\nDEBUG verifyOffChainProperties');
                console.log('rootHash: ' + rootHash);
                console.log('properties: ' + properties);
            }
            if (theProof) {
                if (!ew_utils_general_precise_proofs_1.PreciseProofs.verifyProof(rootHash, theProof, schema)) {
                    throw new Error(`Proof for property ${key} is invalid.`);
                }
            }
            else {
                throw new Error(`Could not find proof for property ${key}`);
            }
        });
    }
    generateAndAddProofs(properties, debug, salts) {
        this.proofs = [];
        let leafs = salts ? ew_utils_general_precise_proofs_1.PreciseProofs.createLeafs(properties, salts) :
            ew_utils_general_precise_proofs_1.PreciseProofs.createLeafs(properties);
        leafs = ew_utils_general_precise_proofs_1.PreciseProofs.sortLeafsByKey(leafs);
        const merkleTree = ew_utils_general_precise_proofs_1.PreciseProofs.createMerkleTree(leafs.map((leaf) => leaf.hash));
        leafs.forEach((leaf) => this.addProof(ew_utils_general_precise_proofs_1.PreciseProofs.createProof(leaf.key, leafs, true, merkleTree)));
        const schema = leafs.map((leaf) => leaf.key);
        const result = {
            rootHash: ew_utils_general_precise_proofs_1.PreciseProofs.createExtendedTreeRootHash(merkleTree[merkleTree.length - 1][0], schema),
            salts: leafs.map((leaf) => leaf.salt),
            schema,
        };
        if (debug) {
            console.log('\nDEBUG generateAndAddProofs');
            console.log(result);
            ew_utils_general_precise_proofs_1.PreciseProofs.printTree(merkleTree, leafs, schema);
        }
        return result;
    }
}
exports.Entity = Entity;
//# sourceMappingURL=BlockchainDataModelEntity.js.map