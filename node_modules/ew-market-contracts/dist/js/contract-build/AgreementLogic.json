{ "abi": [{ "constant": false, "inputs": [{ "name": "_supplyId", "type": "uint256" }], "name": "abortSupply", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "name": "_newLogic", "type": "address" }], "name": "update", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [], "name": "getAllAgreementListLength", "outputs": [{ "name": "", "type": "uint256" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [{ "name": "_agreementId", "type": "uint256" }], "name": "getDemandForAgreement", "outputs": [{ "name": "_demandId", "type": "uint256" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "userContractLookup", "outputs": [{ "name": "", "type": "address" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "name": "_demandId", "type": "uint256" }, { "name": "_supplyId", "type": "uint256" }], "name": "createAgreement", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [], "name": "db", "outputs": [{ "name": "", "type": "address" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [{ "name": "_agreementId", "type": "uint256" }], "name": "getAgreement", "outputs": [{ "name": "_demandId", "type": "uint256" }, { "name": "_supplyIds", "type": "uint256" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [{ "name": "_agreementId", "type": "uint256" }], "name": "getDemandForAgreementPublic", "outputs": [{ "name": "_demandId", "type": "uint256" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "assetContractLookup", "outputs": [{ "name": "", "type": "address" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "owner", "outputs": [{ "name": "", "type": "address" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [{ "name": "_supplyId", "type": "uint256" }], "name": "getAgreementForSupplyPublic", "outputs": [{ "name": "_agreementId", "type": "uint256" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "name": "_newOwner", "type": "address" }], "name": "changeOwner", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [{ "name": "_supplyId", "type": "uint256" }], "name": "getAgreementForSupply", "outputs": [{ "name": "_agreementId", "type": "uint256" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [{ "name": "_role", "type": "uint8" }, { "name": "_caller", "type": "address" }], "name": "isRole", "outputs": [{ "name": "", "type": "bool" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [{ "name": "_agreementId", "type": "uint256" }], "name": "getAgreementStruct", "outputs": [{ "components": [{ "name": "demandId", "type": "uint256" }, { "name": "supplyId", "type": "uint256[]" }], "name": "", "type": "tuple" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "name": "_database", "type": "address" }, { "name": "_admin", "type": "address" }], "name": "init", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "name": "_assetContractLookup", "type": "address" }, { "name": "_marketContractLookup", "type": "address" }], "payable": false, "stateMutability": "nonpayable", "type": "constructor" }, { "anonymous": false, "inputs": [{ "indexed": true, "name": "_agreementId", "type": "uint256" }, { "indexed": true, "name": "_demandId", "type": "uint256" }, { "indexed": true, "name": "_supplyId", "type": "uint256" }], "name": "LogAgreementFullySigned", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "name": "_agreementId", "type": "uint256" }, { "indexed": true, "name": "_demandId", "type": "uint256" }], "name": "LogAgreementCreated", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": false, "name": "_newOwner", "type": "address" }], "name": "LogChangeOwner", "type": "event" }], "bytecode": "", "contractName": "AgreementLogic", "deployedBytecode": "", "source": "// Copyright 2018 Energy Web Foundation\n// This file is part of the Origin Application brought to you by the Energy Web Foundation,\n// a global non-profit organization focused on accelerating blockchain technology across the energy sector,\n// incorporated in Zug, Switzerland.\n//\n// The Origin Application is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n// This is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY and without an implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details, at <http://www.gnu.org/licenses/>.\n//\n// @authors: slock.it GmbH; Martin Kuechler, martin.kuchler@slock.it; Heiko Burkhardt, heiko.burkhardt@slock.it\n\npragma solidity ^0.5.2;\npragma experimental ABIEncoderV2;\n\nimport \"../../contracts/Trading/MarketDB.sol\";\nimport \"ew-user-registry-contracts/contracts/Users/RoleManagement.sol\";\nimport \"ew-utils-general-contracts/contracts/Interfaces/Updatable.sol\";\nimport \"ew-asset-registry-contracts/contracts/Interfaces/AssetGeneralInterface.sol\";\nimport \"ew-asset-registry-contracts/contracts/Interfaces/AssetProducingInterface.sol\";\nimport \"ew-asset-registry-contracts/contracts/Interfaces/AssetConsumingInterface.sol\";\nimport \"ew-asset-registry-contracts/contracts/Interfaces/AssetContractLookupInterface.sol\";\nimport \"../../contracts/Interfaces/MarketContractLookupInterface.sol\";\nimport \"../../contracts/Interfaces/AgreementLogicInterface.sol\";\nimport \"ew-asset-registry-contracts/contracts/Interfaces/SonnenAssetProducingInterface.sol\";\n\ncontract AgreementLogic is RoleManagement, Updatable, AgreementLogicInterface {\n\n    event LogAgreementFullySigned(uint indexed _agreementId, uint indexed _demandId, uint indexed _supplyId);\n    event LogAgreementCreated(uint indexed _agreementId, uint indexed _demandId);\n\n    /// @notice database contract\n    MarketDB public db;\n\n    AssetContractLookupInterface public assetContractLookup;\n\n    /// @notice constructor\n    constructor(\n        AssetContractLookupInterface _assetContractLookup,\n        MarketContractLookupInterface _marketContractLookup\n    )\n        RoleManagement(UserContractLookupInterface(_assetContractLookup.userRegistry()), address(_marketContractLookup))\n        public\n    {\n        assetContractLookup = _assetContractLookup;\n    }\n\n\t/// @notice Function to create a agreement\n\t/// @dev will return an event with the event-Id\n\t/// @param _demandId the demand Id\n    function createAgreement(\n        uint _demandId,\n        uint _supplyId\n    )\n        public\n    { \n        uint[] memory supplyInternal = new uint[](1); \n        \n        supplyInternal[0] = _supplyId;   \n\n        uint agreementId = db.createAgreementDB(\n            _demandId,\n            supplyInternal\n        );\n\n        for(uint j = 0; j < supplyInternal.length; j++){\n            MarketDB.Supply memory supply = db.getSupply(supplyInternal[j]);\n\n            for(uint i = 0; i < supply.assetId.length; i++){\n                SonnenAssetProducingInterface(assetContractLookup.assetProducingRegistry()).setMarketPropsCertOwner(supply.assetId[i], msg.sender);\n            }\n        }\n\n    }\n\n    function abortSupply(uint _supplyId) \n        external \n    {\n        AgreementDB.SupplyAgreement memory sa = db.getAgreementForSupply(_supplyId);\n        require(!sa.isSet, \"supply is part of an agreeent\");\n        MarketDB.Supply memory supply = db.getSupply(_supplyId);\n\n        for(uint i = 0; i < supply.assetId.length; i++){\n            SonnenAssetProducingInterface(assetContractLookup.assetProducingRegistry()).clearSonnenAsset(supply.assetId[i]);\n        }\n\n    }\n\n    function getAgreementForSupply(uint _supplyId) \n        external\n        view \n        returns (uint _agreementId)\n    {\n        AgreementDB.SupplyAgreement memory sa = db.getAgreementForSupply(_supplyId);\n        require(sa.isSet,\"no agreement found\");\n        return getAgreementForSupplyPublic(_supplyId);\n    } \n\n\t/// @notice fuction to set the database contract, can only be called once\n\t/// @param _database the database contract\n\t/// @param _admin the admin\n    function init(address _database, address _admin)\n        public\n        onlyOwner\n    {\n        require(address(db) == address(0x0),\"init: already initialize\");\n        db = MarketDB(_database);\n    }\n\n\t/// @notice Updates the logic contract\n\t/// @param _newLogic Address of the new logic contract\n    function update(address _newLogic)\n        external\n        onlyOwner\n    {\n        db.changeOwner(_newLogic);\n    }\n\n\t/// @notice get all agreement list length\n\t/// @return length of the allAgreements-array\n    function getAllAgreementListLength() external view returns (uint) {\n        return db.getAllAgreementListLengthDB();\n    }\n\n\n    function getAgreementStruct(uint _agreementId)\n        external\n        view\n        returns (MarketDB.Agreement memory)\n    {        \n        return db.getAgreementDB(_agreementId);\n    }\n\n    function getAgreement(uint _agreementId)\n        public\n        view\n        returns (\n            uint _demandId,\n            uint _supplyIds\n        )\n    {\n        MarketDB.Agreement memory agreement = db.getAgreementDB(_agreementId);\n        _demandId = agreement.demandId;\n        _supplyIds = agreement.supplyId[0];\n    }\n\n    function getAgreementForSupplyPublic(uint _supplyId) \n        public\n        view \n        returns (uint _agreementId)\n    {\n        AgreementDB.SupplyAgreement memory sa = db.getAgreementForSupply(_supplyId);\n        require(sa.isSet,\"no agreement found\");\n        return sa.agreementId;\n    } \n\n    function getDemandForAgreementPublic(uint _agreementId) public view returns (uint _demandId){\n        MarketDB.Agreement memory a = db.getAgreementDB(_agreementId);\n        return a.demandId; \n    }\n\n  /*\n\t/// @notice approves a demand for an agreement\n\t/// @param _agreementId the agreement Id\n    function approveAgreementDemand(uint _agreementId)\n        public\n    {\n        MarketDB.Agreement memory agreement = db.getAgreementDB(_agreementId);\n   //     require(db.getDemand(agreement.demandId).demandOwner == msg.sender, \"approveAgreementDemand: wrong msg.sender\");\n\n        // we approve a demand. If it's returning true it means that both supply and demand are approved thus making the agreement complete\n        if(db.approveAgreementDemandDB(_agreementId)) {\n            emit LogAgreementFullySigned(_agreementId, agreement.demandId, agreement.supplyId);\n        }\n    }\n\n  \n\t/// @notice approves a supply for an agreement\n\t/// @param _agreementId the agreement Id\n    function approveAgreementSupply(uint _agreementId)\n        public\n    {\n        MarketDB.Agreement memory agreement = db.getAgreementDB(_agreementId);\n        MarketDB.Supply memory supply = db.getSupply(agreement.supplyId);\n\n        require(AssetGeneralInterface(assetContractLookup.assetProducingRegistry()).getAssetOwner(supply.assetId) == msg.sender, \"approveAgreementSupply: wrong msg.sender\");\n\n        // we approve a supply. If it's returning true it means that both supply and demand are approved thus making the agreement complete\n        if(db.approveAgreementSupplyDB(_agreementId)){\n            emit LogAgreementFullySigned(_agreementId, agreement.demandId, agreement.supplyId);\n        }\n    }\n\n    /// @notice sets the matcher for an agreement\n    /// @dev can only be called as long as there are no matchers set\n    /// @param _agreementId the agreement-Id\n    function setAgreementMatcher(uint _agreementId) \n        internal \n    {\n        MarketDB.Agreement memory agreement = db.getAgreementDB(_agreementId);\n\n        assert(agreement.allowedMatcher.length == 0);\n        MarketDB.Supply memory supply = db.getSupply(agreement.supplyId);\n\n        (,,,,,address[] memory matcherArray,,,,) = AssetGeneralInterface(assetContractLookup.assetProducingRegistry()).getAssetGeneral(supply.assetId);\n\n        db.setAgreementMatcher( _agreementId, matcherArray);\n    }\n\n    /// @notice allows matcher to change the matcher-properties for an agreement\n    /// @param _agreementId the agreement-ID\n    /// @param _matcherPropertiesDocumentHash document-hash of the matcher properties\n    /// @param _matcherDBURL db-url of the document-hash\n    function setMatcherProperties(\n        uint _agreementId,\n        string calldata _matcherPropertiesDocumentHash,\n        string calldata _matcherDBURL\n    )\n        external\n    {\n        MarketDB.Agreement memory agreement = db.getAgreementDB(_agreementId);\n\n        require(agreement.approvedBySupplyOwner, \"supply owner has not agreed yet\");\n        require(agreement.approvedByDemandOwner, \"demand owner has not agreed yet\");\n        address[] memory agreementMatcher = agreement.allowedMatcher;\n        \n        bool foundMatcher = false;\n\n        // we have to check all the matchers\n        for(uint i=0; i < agreementMatcher.length; i++){\n\n            if ( agreementMatcher[i] == msg.sender) {\n                foundMatcher = true;\n                break;\n            }\n        }\n\n        require(foundMatcher, \"sender is not in matcher array\");\n\n        db.setMatcherPropertiesAndURL(_agreementId, _matcherPropertiesDocumentHash, _matcherDBURL);\n    \n    }\n    */\n}", "networks": "{}" }
